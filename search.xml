<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CLR的执行模型</title>
    <url>/2019/11/19/CLR%E7%9A%84%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C#</category>
        <category>读书</category>
        <category>CLR via C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>委托</title>
    <url>/2019/11/18/%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书</category>
        <category>CLR via C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>笔记</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的定制特性</title>
    <url>/2019/11/18/Unity%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%88%B6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>C#特性</p>
<p>Unity特性</p>
</blockquote>
<h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><p>C#特性从本质上来说，自定义特性是一个标签。编译器会在托管模块的元数据中嵌入这些额外的信息。大多数的特性对编译器来说并没有意义，编译器只是机械的检测源码中的特性，并生成对应的元数据。</p>
<p>特性其实是一个类型的实例，特性类必须有公共构造用于实例化一个实例。就像<code>[DllImport(&quot;PluginName&quot;)]</code></p>
<p>所有特性直接或者间接的派生于<strong>System.Attribut</strong>，这样符合CLS(Common Language Specification)中关于特性的需求。</p>
<p><strong>Dllmpot特性</strong></p>
<p><strong>Serializable特性</strong></p>
<h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p>Unity中的特性类定义在两个命名空间中- UnityEngine和UnityEditor。同样它们符合CLS。</p>
<h2 id="定义自己的特性类"><a href="#定义自己的特性类" class="headerlink" title="定义自己的特性类"></a>定义自己的特性类</h2><p>自定义的特性用<strong>基础库中的定义的特性类（System.AttributeAttribute）</strong>限制特性的适用范围。</p>
<p>检测特性。</p>
<p><img src="/Users/mlikeryour/Desktop/hexo/source/images/%E7%89%B9%E6%80%A7.png" alt="特性"></p>
<p>备注：</p>
<p>1.整理之前自己用到的C#特性与Unity特性。</p>
<p>2.整理之前写的Unity编辑器扩展。</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>读书</category>
        <category>Unity3D脚本编程</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#特性</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>从序列化和反序列化看Unity3D的存储机制</title>
    <url>/2019/11/18/%E4%BB%8E%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8BUnity3D%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>貌似从来没有看过一本关于Unity的书籍就找了本看看。</p>
<p>本书为《Unity3D脚本编程》</p>
</blockquote>
<p>序列化对象的和反序列化的操作</p>
<p>序列化和反序列化与程序集的关系 </p>
]]></content>
      <categories>
        <category>C#</category>
        <category>Unity</category>
        <category>读书</category>
        <category>Unity3D脚本编程</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>序列化</tag>
        <tag>反序列化</tag>
        <tag>存储机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Type</title>
    <url>/2019/11/16/Type/</url>
    <content><![CDATA[<p>Type类，是一个用来存储类型的特性和信息的类。对于程序中的每一个类型，都会有他自己的类信息，而根据Type提供的书信和方法获得这个类型的一切信息，包括字段，属性，事件，参数，构造函数等。</p>
<h2 id="生成Type对象"><a href="#生成Type对象" class="headerlink" title="生成Type对象"></a>生成Type对象</h2><p>Type type = typeof(Test);<br>Test test= new Test();<br>Type type2 = Test.GetType();</p>
<h2 id="获取该类型的信息"><a href="#获取该类型的信息" class="headerlink" title="获取该类型的信息"></a>获取该类型的信息</h2><p>//类的名称<br>string name = type.Name;<br>//类的命名空间<br>string space = type.Namespace;<br>//类的程序集<br>Assembly assembly = type.Assembly;<br>//类的共有字段<br>FieldInfo[] fieldInfos = type.GetFields();<br>//类的属性<br>PropertyInfo[] propertyInfos = type.GetProperties();<br>//类的方法<br>MethodInfo[] methodInfos = type.GetMethods();</p>
<h2 id="typeof-和GetType的区别"><a href="#typeof-和GetType的区别" class="headerlink" title="typeof 和GetType的区别"></a>typeof 和GetType的区别</h2><p>C#中任何对象都具有GetType()方法，它的作用和typeof()相同，返回Type类型的当前对象的类型。</p>
<p>typeof(x)中的x，必须是具体的类名、类型名称等(int ,string,自定义类等等)，不可以是变量名称；</p>
<p>GetType()是基类System.Object的方法，因此只有建立一个实例之后才能够被调用</p>
<p>typeof是运算符，GetType是一个实例的方法。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity封装DeBug.Log代码定位</title>
    <url>/2019/11/16/Unity%E5%B0%81%E8%A3%85DeBug-Log%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UnityConsoleWindow双击定位Debug.Log输出日志。</p>
<p>但是一般封装Debug.Log日志定位就不是自己想要的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Reflection;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line">using UnityEditor;</span><br><span class="line">public class LogEditor</span><br><span class="line">&#123;  </span><br><span class="line">  private static LogEditor m_Instance;  </span><br><span class="line">  public static LogEditor GetInstacne()</span><br><span class="line">  &#123;</span><br><span class="line">    if (m_Instance == null)</span><br><span class="line">    &#123;</span><br><span class="line">      m_Instance = new LogEditor();</span><br><span class="line">    &#125;    return m_Instance;</span><br><span class="line">  &#125;</span><br><span class="line">  private const string DEBUGERFILEPATH = &quot;Assets/Script/Util/HHLogger.cs&quot;;//替换成你自己的封装类地址</span><br><span class="line">  private int m_DebugerFileInstanceId;</span><br><span class="line">  private Type m_ConsoleWindowType = null;</span><br><span class="line">  private FieldInfo m_ActiveTextInfo;</span><br><span class="line">  private FieldInfo m_ConsoleWindowFileInfo;  </span><br><span class="line">  </span><br><span class="line">  private LogEditor()</span><br><span class="line">  &#123;</span><br><span class="line">    UnityEngine. Object debuggerFile = AssetDatabase.LoadAssetAtPath(DEBUGERFILEPATH,typeof(UnityEngine.Object));</span><br><span class="line">    m_DebugerFileInstanceId = debuggerFile.GetInstanceID();    </span><br><span class="line">    m_ConsoleWindowType = Type.GetType(&quot;UnityEditor.ConsoleWindow,UnityEditor&quot;);</span><br><span class="line">    m_ActiveTextInfo = m_ConsoleWindowType.GetField(&quot;m_ActiveText&quot;, BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">    m_ConsoleWindowFileInfo = m_ConsoleWindowType.GetField(&quot;ms_ConsoleWindow&quot;, BindingFlags.Static | BindingFlags.NonPublic);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  [UnityEditor.Callbacks.OnOpenAssetAttribute(-1)]</span><br><span class="line">  private static bool OnOpenAsset(int instanceID, int line)</span><br><span class="line">  &#123;</span><br><span class="line">    if (instanceID == LogEditor.GetInstacne().m_DebugerFileInstanceId &amp;&amp; line != -1)</span><br><span class="line">    &#123;</span><br><span class="line">      return LogEditor.GetInstacne().FindCode();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public bool FindCode()</span><br><span class="line">  &#123;</span><br><span class="line">    var windowInstance = m_ConsoleWindowFileInfo.GetValue(null);</span><br><span class="line">    var activeText = m_ActiveTextInfo.GetValue(windowInstance);    </span><br><span class="line">    string[] contentStrings = activeText.ToString().Split(&apos;\n&apos;);</span><br><span class="line">    List&lt;string&gt; filePath = new List&lt;string&gt;();</span><br><span class="line">    for (int index = 0; index &lt; contentStrings.Length; index++)</span><br><span class="line">    &#123;</span><br><span class="line">      if (contentStrings[index].Contains(&quot;at&quot;))</span><br><span class="line">      &#123;</span><br><span class="line">        filePath.Add(contentStrings[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    bool success = PingAndOpen(filePath[1]);</span><br><span class="line">    return success;</span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  public bool PingAndOpen(string fileContext)</span><br><span class="line">  &#123;</span><br><span class="line">    string regexRule = @&quot;at ([\w\W]*):(\d+)\)&quot;;    </span><br><span class="line">    Match match = Regex.Match(fileContext, regexRule);</span><br><span class="line">    if (match.Groups.Count &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">      string path = match.Groups[1].Value;</span><br><span class="line">      string line = match.Groups[2].Value;</span><br><span class="line">      UnityEngine.Object codeObject = AssetDatabase.LoadAssetAtPath(path, typeof(UnityEngine.Object));</span><br><span class="line">      if (codeObject == null)</span><br><span class="line">      &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;      </span><br><span class="line">      EditorGUIUtility.PingObject(codeObject);</span><br><span class="line">      AssetDatabase.OpenAsset(codeObject, int.Parse(line));      </span><br><span class="line">      return true;</span><br><span class="line">    &#125;    </span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static class HHLogger</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  // 正式发布改成true</span><br><span class="line">  static bool isTrue = false;</span><br><span class="line">  //static bool isTrue = true;</span><br><span class="line"></span><br><span class="line">  public static void DEBUG(params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    if (isTrue)</span><br><span class="line">      return;</span><br><span class="line">    object msg;</span><br><span class="line">    parseParams(out msg, arrParams);</span><br><span class="line">    Debug.Log(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void WARN(params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    if (isTrue)</span><br><span class="line">      return;</span><br><span class="line">    object msg;</span><br><span class="line">    parseParams(out msg, arrParams);</span><br><span class="line">    Debug.LogWarning(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void ERROR(params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    if (isTrue)</span><br><span class="line">      return;</span><br><span class="line">    object msg;</span><br><span class="line">    parseParams(out msg, arrParams);</span><br><span class="line">    Debug.LogError(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void parseParams(out object msg, params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    msg = string.Empty;</span><br><span class="line">    for (int i = 0; i &lt; arrParams.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      msg += &quot;[&quot; + arrParams[i] + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.cppblog.com/heath/archive/2016/06/21/213777.html" target="_blank" rel="noopener">解决在Unity中封装Debug.Log后代码行定位问题</a></p>
<p><a href="https://blog.csdn.net/sinat_34870723/article/details/84979106" target="_blank" rel="noopener">https://blog.csdn.net/sinat_34870723/article/details/84979106</a></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>代码块</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>代码块</tag>
        <tag>打印</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-打印帧率</title>
    <url>/2019/11/14/Unity-%E6%89%93%E5%8D%B0%E5%B8%A7%E7%8E%87/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ShowFPS : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public int fpsTarget;</span><br><span class="line"></span><br><span class="line">    public float updateInterval = 0.5f;</span><br><span class="line">    private float lastInterval;</span><br><span class="line">    private int frames = 0;</span><br><span class="line">    private float fps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        //设置帧率</span><br><span class="line">        Application.targetFrameRate = 60;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lastInterval = Time.realtimeSinceStartup;</span><br><span class="line">        frames = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Update is called once per frame  </span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        ++frames;</span><br><span class="line">        float timeNow = Time.realtimeSinceStartup;</span><br><span class="line">        if (timeNow &gt;= lastInterval + updateInterval)</span><br><span class="line">        &#123;</span><br><span class="line">            fps = frames / (timeNow - lastInterval);</span><br><span class="line">            frames = 0;</span><br><span class="line">            lastInterval = timeNow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        GUI.Label(new Rect(200, 40, 100, 30), fps.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity</category>
        <category>代码块</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>代码块</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity插件-TouchConsole</title>
    <url>/2019/11/14/Unity%E6%8F%92%E4%BB%B6-TouchConsole/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>打印</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言</title>
    <url>/2019/11/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>提到汇编语言不得不提机器语言</p>
<ul>
<li>机器语言</li>
</ul>
<p>机器语言：机器指令的集合（二进制数字0，1）<br>计算机转变为一列高低电平，以使计算机的电子器受到驱动，进行运算。</p>
<ul>
<li>汇编语言 </li>
</ul>
<p>实质与机器语言相同，直接对硬件操作。将源程序汇编生成的<strong>可执行文件</strong><br>组成：指令、伪指令和宏指令</p>
<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>高级语言是依赖编译或者解析的<br>如：C、C++、Python、Java、Matlab、LabVIEW等等</p>
<ul>
<li>低级语言：泛指机器语言和汇编语言</li>
</ul>
<h3 id="按转换方式划分"><a href="#按转换方式划分" class="headerlink" title="按转换方式划分"></a>按转换方式划分</h3><ul>
<li>解释型：一边“翻译”成目标代码（机器语言）一边执行</li>
<li>编译型：应用源程序执行之前，就将程序源代码“翻译”成目标代码（机器语言）</li>
</ul>
<p>解释型语言中包括脚本语言（又叫动态语言，扩建的语言）</p>
<ul>
<li>脚本语言：shell，Lua，php</li>
</ul>
<p>脚本语言作为一钟解释型语言，一般以文本的形式存在，<strong>脚本语言可分为独立型和嵌入型</strong>，独立型脚本语言在其执行时完全依赖于解释器，而嵌入型脚本语言通常在编程语言中（如C，C++，VB，Java等）被嵌入使用。</p>
<h3 id="其他分类方式"><a href="#其他分类方式" class="headerlink" title="其他分类方式"></a>其他分类方式</h3><ul>
<li>动态语言：语言的数据类型判断是在运行中判断</li>
<li>静态语言：语言的数据类型判断是在运行前判断（如编译阶段）如：C、C++，C#，java</li>
</ul>
<ul>
<li>强类型语言：变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换 如：Java</li>
<li>弱类型语言：它与强类型语言定义相反,允许编译器进行隐式的类型转换如：C、C++<h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2></li>
<li>动态语言和静态语言</li>
<li>强类型语言和弱类型语言</li>
<li>解释型语言和编译型语言</li>
<li>机器语言和汇编语言<h2 id="分析案例"><a href="#分析案例" class="headerlink" title="分析案例"></a>分析案例</h2></li>
<li>C#</li>
<li>C</li>
<li>C++</li>
<li>Java</li>
<li>Lua</li>
<li>Pyhon<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2></li>
<li>CLR和.Net</li>
</ul>
<p>.Net是一种解决方案; C# 是.Net解决方案中的一种语言; CLR是.Net的运行架构.</p>
<ol>
<li>CLR是公共语言运行库(Common Language Runtime)和Java虚拟机<br>一样也是一个运行时环境，它负责资源管理(内存分配和垃圾收集等),并保<br>证应用和底层操作系统之间必要的分离。</li>
<li>NET FrameWork的核心是其运行库执行环境，称为公共语言运行库(Common Language Runtime)。</li>
<li>作用：<br>（1）CLR是一个类似于JVM的虚拟机，为微软的.Net产品提供运行环境。<br>（2）CLR上实际运行的并不是我们通常所用的编程语言(例如C#、VB等)，而是一种字节码形态的“中间语言”。<br>这意味着只要能将代码编译成这种特定的“中间语言”(MSIL),任何语言的产品都能运行在CLR上。<br>（3）CLR通常被运行在Windows系统上，但是也有一些非Windows的版本。这意味着.Net也很容易实现<br>“跨平台”。(至于为什么大家的印象中.Net的跨平台性不如Java，更多的是微软商业战略导致的)。<br>语言支持：<br>微软已经为多种语言开发了基于CLR的编译器，这些语言包括：C++/CLI、C#、Visual Basic、F#、<br>Iron Python、 Iron Ruby和IL。除此之外，其他的一些公司和大学等机构也位一些语言开发了基于CLR<br>的编译器，例如Ada、APL、Caml、COBOL、Eiffel、Forth、Fortran、Haskell、Lexicon、LISP、<br>LOGO、Lua、Mercury、ML、Mondrian、Oberon、Pascal、Perl、PHP、Prolog、RPG、Scheme、<br>Smaltak、Tcl/Tk。</li>
</ol>
<p>CLR为不同的编程语言提供了统一的运行平台，在很大程度上对上层开发者屏蔽了语言之间才特性差异。<br>对于CLR来说，不同语言的编译器(Compiler)就相当于一个这种语言的代码审查者(Checker),所做的<br>工作就是检查源码语法是否正确，然后将源码编译成CLR所需要的中间语言(IL)。所以编程语言对于CLR<br>是透明的，也就是说CLR只知道IL的存在，而不知道IL是由哪种语言编译而来。<br>功能：<br>（1）基类库支持 (Base Class Library Support)<br>（2）内存管理 (Memory Management)<br>（3）线程管理 (Thread Management)<br>（4）垃圾回收 (Garbage Collection)<br>（5）安全性 (Security)<br>（6）类型检查 (Type Checker)<br>（7）异常处理 (Exception Manager)<br>（8）即时编译 (JIT)<br><img src="https://img-blog.csdnimg.cn/20190729183322381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190729190632358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>具体过程：<br>CIL（IL）： CIL类似一个面向对象的汇编语言，并且它是完全基于堆栈的，它运行在虚拟机上（.Net Framework, Mono VM）的语言<br>遵循LI规范的高级语言，被先被各自的编译器编译成中间语言：IL（CIL），等到需要真正执行的时候，这些IL会被加载到运行时库，也就是VM中，由<strong>VM</strong>动态的编译成汇编代码（JIT）然后在执行。<br>IL2CPP <a href="https://www.cnblogs.com/lancidie/p/6258154.html" target="_blank" rel="noopener">https://www.cnblogs.com/lancidie/p/6258154.html</a> ：Mono vm –&gt;IL2CPP vm</p>
<ul>
<li>AOT和JIT</li>
</ul>
<p><a href="https://blog.csdn.net/h1130189083/article/details/78302502" target="_blank" rel="noopener">https://blog.csdn.net/h1130189083/article/details/78302502</a></p>
<ul>
<li>程序集的组成</li>
</ul>
<p>1.程序集清单，包含描述该程序集中各元素彼此如何关联的数据集合，还包含指定该程序集的版本要求和安全标识所需的所有元数据，以及定义该程序集的范围和解析对资源和类的应用所需的全部元数据。<br>2.元数据，提供有关程序集中定义的类型的信息，包括类型的名称，可见性，基类和类型所实现的接口。注意：程序集清单和元数据说明了程序集是自我描述的。<br>3.实现这些类型的MSIL代码。<br>4.资源集，诸如位图，指针，静态文本等。</p>
<ul>
<li>程序集和命名空间的关系</li>
</ul>
<p>命名空间用于对类型进行逻辑分组。<strong>程序集则是程序的物理分组，对应于一个dll或exe文件。</strong><br>程序集1：<br>namespace1{<br>    public class A1{…}<br>    public class A2{…}<br>}</p>
<p>namespace2{<br>    public class A3{…}<br>    public class A4{…}<br>}</p>
<p>程序集2：<br>namespace1{<br>    public class B1{…}<br>    public class B2{…}<br>}</p>
<p>namesapce2{<br>    public class B3{…}<br>    public class B4{…}<br>}<br><a href="https://blog.csdn.net/DY_1024/article/details/82946643" target="_blank" rel="noopener">https://blog.csdn.net/DY_1024/article/details/82946643</a> </p>
<ul>
<li>托管模块</li>
</ul>
<p>中间语言代码（Microsoft Intermediate Language MSIL==IL)就是托管代码）<br><img src="https://img-blog.csdnimg.cn/2019072919413937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190729194154717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>编程语言</tag>
        <tag>CLR</tag>
        <tag>.Net</tag>
        <tag>程序集</tag>
        <tag>托管模块</tag>
        <tag>托管语言</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityMono脚本</title>
    <url>/2019/11/06/UnityMono%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h1><p><img src="../images/mono_1.jpg" alt="mono_1"></p>
<p>TODO 现在的垃圾回收机制</p>
<p>TODO 现在IL2Cpp喝MONO的区别 到底改变的是什么</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityWWW类的用法</title>
    <url>/2019/11/05/UnityWWW%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h1><p>支持get和post两种方式 -TODO get poss http传送区别</p>
<p><a href="https://www.cnblogs.com/Jason-c/p/10559141.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jason-c/p/10559141.html</a></p>
<p><a href="https://blog.csdn.net/yzy565280261/article/details/80146097" target="_blank" rel="noopener">https://blog.csdn.net/yzy565280261/article/details/80146097</a></p>
<p>TODO TCP HTTP UDP</p>
<p>TODO <a href="https://www.jianshu.com/p/cd185f40c53a" target="_blank" rel="noopener">https://www.jianshu.com/p/cd185f40c53a</a></p>
<p><a href="https://www.cnblogs.com/hanfanfan/p/9579771.html" target="_blank" rel="noopener">https://www.cnblogs.com/hanfanfan/p/9579771.html</a></p>
<p>扩展封装</p>
<p><a href="https://blog.csdn.net/lizhenxiqnmlgb/article/details/82864230" target="_blank" rel="noopener">https://blog.csdn.net/lizhenxiqnmlgb/article/details/82864230</a></p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>异步、并发、协程原理</title>
    <url>/2019/10/31/%E5%BC%82%E6%AD%A5%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、异步"><a href="#一、异步" class="headerlink" title="一、异步"></a>一、异步</h2><h2 id="应用程序和内核"><a href="#应用程序和内核" class="headerlink" title="应用程序和内核"></a>应用程序和内核</h2><p>内核具有最高权限，可以访问受保护的内存空间，可以访问底层的硬件设备。而这些是应用程序所不具备的，但应用程序可以通过调用内核提供的接口来间接访问或操作。所谓的常见的 IO 模型就是基于应用程序和内核之间的交互所提出来的。以一次网络 IO 请求过程中的 read 操作为例，请求数据会先拷贝到系统内核的缓冲区（内核空间），再从操作系统的内核缓冲区拷贝到应用程序的地址空间（用户空间）。而从内核空间将数据拷贝到用户空间过程中，就会经历两个阶段：</p>
<ul>
<li>等待数据准备</li>
<li>拷贝数据</li>
</ul>
<p>也正因为有了这两个阶段，才提出了各种网络 I/O 模型。</p>
<h3 id="Unix-Linux的体系架构"><a href="#Unix-Linux的体系架构" class="headerlink" title="Unix/Linux的体系架构"></a>Unix/Linux的体系架构</h3><p><img src="http://www.iigrowing.cn/wp-content/uploads/2018/09/52599826b6c16e428b2f6999907e4703.png" alt="img"></p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步（Synchronised）和异步（Asynchronized）的概念描述的是应用程序与内核的交互方式，同步是指应用程序发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行；而异步是指应用程序发起 I/O 请求后仍继续执行，当内核 I/O 操作完成后会通知应用程序，或者调用应用程序注册的回调函数。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞的概念描述的是应用程序调用内核 IO 操作的方式，阻塞是指 I/O 操作需要彻底完成后才返回到用户空间；而非阻塞是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。</p>
<p><strong>常见的网络I/O模型大概有四种：</strong></p>
<ol>
<li>同步阻塞IO（Blocking IO）</li>
<li>同步非阻塞IO（Non-blocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>异步IO（Asynchronous IO）</li>
</ol>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）。 <strong>IO 多路复用是异步阻塞的。</strong></p>
<h2 id="二、并发"><a href="#二、并发" class="headerlink" title="二、并发"></a>二、并发</h2><p>并发，在操作系统中，是指 <strong>一个时间段</strong> 中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<p><strong>并发和并行的区别：</strong></p>
<ul>
<li>并发（concurrency）：逻辑上具备同时处理多个任务的能力。</li>
<li>并行（parallesim）：物理上在同一时刻执行多个并发任务，依赖多核处理器等物理设备。</li>
</ul>
<p>多线程或多进程是并行的基本条件，但单线程也可用协程做到并发。通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源；用协程来提高处理器时间片利用率。现代系统中，多核 CPU 可以同时运行多个不同的进程或者线程。所以并发程序可以是并行的，也可以不是。</p>
<h2 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h2><p>在了解协程前先了解一些概念：</p>
<h3 id="1、线程模型"><a href="#1、线程模型" class="headerlink" title="1、线程模型"></a>1、线程模型</h3><p>在现代计算机结构中，先后提出过两种线程模型：用户级线程（user-level threads）和内核级线程（kernel-level threads）。所谓用户级线程是指，应用程序在操作系统提供的单个控制流的基础上，通过在某些控制点（比如系统调用）上分离出一些虚拟的控制流，从而模拟多个控制流的行为。由于应用程序对指令流的控制能力相对较弱，所以，用户级线程之间的切换往往受线程本身行为以及线程控制点选择的影响，线程是否能公平地获得处理器时间取决于这些线程的代码特征。而且，支持用户级线程的应用程序代码很难做到跨平台移植，以及对于多线程模型的透明。用户级线程模型的优势是线程切换效率高，因为它不涉及系统内核模式和用户模式之间的切换；另一个好处是应用程序可以采用适合自己特点的线程选择算法，可以根据应用程序的逻辑来定义线程的优先级，当线程数量很大时，这一优势尤为明显。但是，这同样会增加应用程序代码的复杂性。有一些软件包（如 POSIXThreads 或 Pthreads 库）可以减轻程序员的负担。</p>
<p>内核级线程往往指操作系统提供的线程语义，由于操作系统对指令流有完全的控制能力，甚至可以通过硬件中断来强迫一个进程或线程暂停执行，以便把处理器时间移交给其他的进程或线程，所以，内核级线程有可能应用各种算法来分配处理器时间。线程可以有优先级，高优先级的线程被优先执行，它们可以抢占正在执行的低优先级线程。在支持线程语义的操作系统中，处理器的时间通常是按线程而非进程来分配，因此，系统有必要维护一个全局的线程表，在线程表中记录每个线程的寄存器、状态以及其他一些信息。然后，系统在适当的时候挂起一个正在执行的线程，选择一个新的线程在当前处理器上继续执行。这里“适当的时候”可以有多种可能，比如：当一个线程执行某些系统调用时，例如像 sleep 这样的放弃执行权的系统函数，或者像 wait 或 select 这样的阻塞函数；硬中断（interrupt）或异常（exception）；线程终止时，等等。由于这些时间点的执行代码可能分布在操作系统的不同位置，所以，在现代操作系统中，线程调度（thread scheduling）往往比较复杂，其代码通常分布在内核模块的各处。</p>
<p>内核级线程的好处是，应用程序无须考虑是否要在适当的时候把控制权交给其他的线程，不必担心自己霸占处理器而导致其他线程得不到处理器时间。应用线程只要按照正常的指令流来实现自己的逻辑即可，内核会妥善地处理好线程之间共享处理器的资源分配问题。然而，这种对应用程序的便利也是有代价的，即，所有的线程切换都是在内核模式下完成的，因此，对于在用户模式下运行的线程来说，一个线程被切换出去，以及下次轮到它的时候再被切换进来，要涉及两次模式切换：从用户模式切换到内核模式，再从内核模式切换回用户模式。在 Intel 的处理器上，这种模式切换大致需要几百个甚至上千个处理器指令周期。但是，随着处理器的硬件速度不断加快，模式切换的开销相对于现代操作系统的线程调度周期（通常几十毫秒）的比例正在减小，所以，这部分开销是完全可以接受的。</p>
<p>除了线程切换的开销是一个考虑因素以外，线程的创建和删除也是一个重要的考虑指标。当线程的数量较多时，这部分开销是相当可观的。虽然线程的创建和删除比起进程要轻量得多，但是，在一个进程内建立起一个线程的执行环境，例如，分配线程本身的数据结构和它的调用栈，完成这些数据结构的初始化工作，以及完成与系统环境相关的一些初始化工作，这些负担是不可避免的。另外，当线程数量较多时，伴随而来的线程切换开销也必然随之增加。所以，当应用程序或系统进程需要的线程数量可能比较多时，通常可采用线程池技术作为一种优化措施，以降低创建和删除线程以及线程频繁切换而带来的开销。</p>
<p>在支持内核级线程的系统环境中，进程可以容纳多个线程，这导致了多线程程序设计（multithreaded programming）模型。由于多个线程在同一个进程环境中，它们共享了几乎所有的资源，所以，线程之间的通信要方便和高效得多，这往往是进程间通信（IPC，Inter-Process Communication）所无法比拟的，但是，这种便利性也很容易使线程之间因同步不正确而导致数据被破坏，而且，这种错误存在不确定性，因而相对来说难以发现和调试。</p>
<h3 id="2、什么是协同式和抢占式？"><a href="#2、什么是协同式和抢占式？" class="headerlink" title="2、什么是协同式和抢占式？"></a>2、什么是协同式和抢占式？</h3><p>许多协同式多任务操作系统，也可以看成协程运行系统。说到协同式多任务系统，一个常见的误区是认为协同式调度比抢占式调度“低级”，因为我们所熟悉的桌面操作系统，都是从协同式调度（如 Windows 3.2， Mac OS 9 等）过渡到抢占式多任务系统的。实际上，调度方式并无高下，完全取决于应用场景。抢占式系统允许操作系统剥夺进程执行权限，抢占控制流，因而天然适合服务器和图形操作系统，因为调度器可以优先保证对用户交互和网络事件的快速响应。当年 Windows 95 刚刚推出的时候，抢占式多任务就被作为一大买点大加宣传。协同式调度则等到进程时间片用完或系统调用时转移执行权限，因此适合实时或分时等等对运行时间有保障的系统。</p>
<p>另外，抢占式系统依赖于 CPU 的硬件支持。 因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有 CPU 支持了执行权限后，抢占式调度才成为可能。x86 系统从 80386 处理器开始引入 Ring 机制支持执行权限，这也是为何 Windows 95 和 Linux 其实只能运行在 80386 之后的 x86 处理器上的原因。而协同式多任务适用于那些没有处理器权限支持的场景，这些场景包含资源受限的嵌入式系统和实时系统。在这些系统中，程序均以协程的方式运行。调度器负责控制流的让出和恢复。通过协程的模型，无需硬件支持，我们就可以在一个“简陋”的处理器上实现一个多任务的系统。我们见到的许多智能设备，如运动手环，基于硬件限制，都是采用协同调度的架构。</p>
<h3 id="协程基本概念"><a href="#协程基本概念" class="headerlink" title="协程基本概念"></a>协程基本概念</h3><p>“协程”（Coroutine）概念最早由 Melvin Conway 于 1958 年提出。协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。总的来说，协程为协同任务提供了一种运行时抽象，这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。</p>
<p>从编程角度上看，协程的思想本质上就是控制流的主动让出（yield）和恢复（resume）机制，迭代器常被用来实现协程，所以大部分的语言实现的协程中都有 yield 关键字，比如 Python、PHP、Lua。但也有特殊比如 Go 就使用的是通道来通信。</p>
<p>有趣的是协程的历史其实要早于线程。</p>
<p>WIKI 的解释：</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as <strong>cooperative tasks, exceptions, event loop, iterators, infinite lists and pipes.</strong></p>
</blockquote>
<h3 id="进程、线程、协程的特点及区别"><a href="#进程、线程、协程的特点及区别" class="headerlink" title="进程、线程、协程的特点及区别"></a>进程、线程、协程的特点及区别</h3><p><a href="https://blog.csdn.net/chengqiuming/article/details/80573288" target="_blank" rel="noopener">对比图</a></p>
<h4 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h4><ul>
<li>进程是资源分配的最小单位</li>
<li>进程间不共享内存，每个进程拥有自己独立的内存</li>
<li>进程间可以通过信号、信号量、共享内存、管道、队列等来通信</li>
<li>新开进程开销大，并且 CPU 切换进程成本也大</li>
<li>进程由操作系统调度</li>
<li>多进程方式比多线程更加稳定</li>
</ul>
<h4 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h4><ul>
<li>线程是程序执行流的最小单位</li>
<li>线程是来自于进程的，一个进程下面可以开多个线程</li>
<li>每个线程都有自己一个栈，不共享栈，但多个线程能共享同一个属于进程的堆</li>
<li>线程因为是在同一个进程内的，可以共享内存</li>
<li>线程也是由操作系统调度，线程是 CPU 调度的最小单位</li>
<li>新开线程开销小于进程，CPU 在切换线程成本也小于进程</li>
<li>某个线程发生致命错误会导致整个进程崩溃</li>
<li>线程间读写变量存在锁的问题处理起来相对麻烦</li>
</ul>
<h4 id="协程（coroutine）"><a href="#协程（coroutine）" class="headerlink" title="协程（coroutine）"></a>协程（coroutine）</h4><ul>
<li>对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的</li>
<li>协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权</li>
<li>切换非常快，成本低。一般占用栈大小远小于线程（协程 KB 级别，线程 MB 级别），所以可以开更多的协程</li>
<li>协程比线程更轻量级</li>
</ul>
<p><strong>不同模型下用户空间与内核空间的关系：</strong></p>
<p><img src="http://www.iigrowing.cn/wp-content/uploads/2018/09/0f8aeb27d963b1c8ed371a1a3c9d4d07.png" alt="img"></p>
<p>注：协程可以理解为上图中的用户级线程模型。</p>
<h4 id="支持协程的语言"><a href="#支持协程的语言" class="headerlink" title="支持协程的语言"></a>支持协程的语言</h4><ul>
<li>Simula</li>
<li>Modula-2</li>
<li>C#</li>
<li>Lua</li>
<li>Go</li>
<li>JavaScript(ECMA-262 6th Edition)</li>
<li>Python</li>
<li>Ruby</li>
<li>Erlang</li>
<li>PHP（PHP5.5+）</li>
<li>…</li>
</ul>
<p><a href="http://www.iigrowing.cn/?p=6736" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>异步</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>编码：ASCII，Unicode和UTF-8</title>
    <url>/2019/10/30/%E7%BC%96%E7%A0%81%EF%BC%9AASCII%EF%BC%8CUnicode%E5%92%8CUTF-8/</url>
    <content><![CDATA[<h2 id="一、ASCII-码"><a href="#一、ASCII-码" class="headerlink" title="一、ASCII 码"></a><strong>一、ASCII 码</strong></h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有<code>0</code>和<code>1</code>两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从<code>00000000</code>到<code>11111111</code>。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>
<p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p>
<h2 id="二、非-ASCII-编码"><a href="#二、非-ASCII-编码" class="headerlink" title="二、非 ASCII 编码"></a><strong>二、非 ASCII 编码</strong></h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的<code>é</code>的编码为130（二进制<code>10000010</code>）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p>
<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>
<p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>
<p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p>
<h2 id="三-Unicode"><a href="#三-Unicode" class="headerlink" title="三. Unicode"></a><strong>三. Unicode</strong></h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p>
<h2 id="四、Unicode-的问题"><a href="#四、Unicode-的问题" class="headerlink" title="四、Unicode 的问题"></a><strong>四、Unicode 的问题</strong></h2><p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<p>比如，汉字<code>严</code>的 Unicode 是十六进制数<code>4E25</code>，转换成二进制数足足有15位（<code>100111000100101</code>），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p>
<h2 id="五、UTF-8"><a href="#五、UTF-8" class="headerlink" title="五、UTF-8"></a><strong>五、UTF-8</strong></h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</strong></p>
<p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">&gt; (十六进制)        |              （二进制）</span><br><span class="line">&gt; ----------------------+---------------------------------------------</span><br><span class="line">&gt; 0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">&gt; 0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">&gt; 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">&gt; 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p>
<p><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p>
<h2 id="六、Unicode-与-UTF-8-之间的转换"><a href="#六、Unicode-与-UTF-8-之间的转换" class="headerlink" title="六、Unicode 与 UTF-8 之间的转换"></a><strong>六、Unicode 与 UTF-8 之间的转换</strong></h2><p>通过上一节的例子，可以看到<code>严</code>的 Unicode码 是<code>4E25</code>，UTF-8 编码是<code>E4B8A5</code>，两者是不一样的。它们之间的转换可以通过程序实现。</p>
<p>Windows平台，有一个最简单的转化方法，就是使用内置的记事本小程序<code>notepad.exe</code>。打开文件后，点击<code>文件</code>菜单中的<code>另存为</code>命令，会跳出一个对话框，在最底部有一个<code>编码</code>的下拉条。</p>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/bg2007102801.jpg" target="_blank" rel="noopener"><img src="http://www.ruanyifeng.com/blog/2007/10/bg2007102801-thumb.jpg" alt="bg2007102801.jpg"></a></p>
<p>里面有四个选项：<code>ANSI</code>，<code>Unicode</code>，<code>Unicode big endian</code>和<code>UTF-8</code>。</p>
<p>1）<code>ANSI</code>是默认的编码方式。对于英文文件是<code>ASCII</code>编码，对于简体中文文件是<code>GB2312</code>编码（只针对 Windows 简体中文版，如果是繁体中文版会采用 Big5 码）。</p>
<p>2）<code>Unicode</code>编码这里指的是<code>notepad.exe</code>使用的 UCS-2 编码方式，即直接用两个字节存入字符的 Unicode 码，这个选项用的 little endian 格式。</p>
<p>3）<code>Unicode big endian</code>编码与上一个选项相对应。我在下一节会解释 little endian 和 big endian 的涵义。</p>
<p>4）<code>UTF-8</code>编码，也就是上一节谈到的编码方法。</p>
<p>选择完”编码方式”后，点击”保存”按钮，文件的编码方式就立刻转换好了。</p>
<h2 id="七、Little-endian-和-Big-endian"><a href="#七、Little-endian-和-Big-endian" class="headerlink" title="七、Little endian 和 Big endian"></a><strong>七、Little endian 和 Big endian</strong></h2><p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过<code>0xFFFF</code>）。以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p>
<p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p>
<h2 id="八、实例"><a href="#八、实例" class="headerlink" title="八、实例"></a><strong>八、实例</strong></h2><p>下面，举一个实例。</p>
<p>打开”记事本”程序<code>notepad.exe</code>，新建一个文本文件，内容就是一个<code>严</code>字，依次采用<code>ANSI</code>，<code>Unicode</code>，<code>Unicode big endian</code>和<code>UTF-8</code>编码方式保存。</p>
<p>然后，用文本编辑软件<a href="http://www.google.cn/search?aq=t&oq=UltraEdit&complete=1&hl=zh-CN&newwindow=1&rlz=1B3GGGL_zh-CNCN216CN216&q=ultraedit+下载&btnG=Google+搜索&meta=" target="_blank" rel="noopener">UltraEdit 中</a>的”十六进制功能”，观察该文件的内部编码方式。</p>
<p>1）ANSI：文件的编码就是两个字节<code>D1 CF</code>，这正是<code>严</code>的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的。</p>
<p>2）Unicode：编码是四个字节<code>FF FE 25 4E</code>，其中<code>FF FE</code>表明是小头方式存储，真正的编码是<code>4E25</code>。</p>
<p>3）Unicode big endian：编码是四个字节<code>FE FF 4E 25</code>，其中<code>FE FF</code>表明是大头方式存储。</p>
<p>4）UTF-8：编码是六个字节<code>EF BB BF E4 B8 A5</code>，前三个字节<code>EF BB BF</code>表示这是UTF-8编码，后三个<code>E4B8A5</code>就是<code>严</code>的具体编码，它的存储顺序与编码顺序是一致的。</p>
<p>Uncode.org == <a href="https://home.unicode.org/" target="_blank" rel="noopener">https://home.unicode.org/</a></p>
<p>链接</p>
<p> <a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">https://blog.csdn.net/Deft_MKJing/article/details/79460485</a></p>
<p> <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>ascll</tag>
        <tag>unicode</tag>
        <tag>utf-8</tag>
      </tags>
  </entry>
  <entry>
    <title>Coroutine</title>
    <url>/2019/10/25/Coroutine/</url>
    <content><![CDATA[<h1 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h1><p>##定义</p>
<p><strong>Process -&gt; Thread -&gt; Coroutine</strong></p>
<p><strong>协程(Coroutine)编译器级的，进程(Process)和线程(Thread)操作系统级的</strong></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>非线程切换的执行效率，切换由程序本身控制</p>
</li>
<li><p>不需要多线程的锁机制</p>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/2782f8c49b2a" target="_blank" rel="noopener">参考文档</a></p>
<p>详见-本博客异步</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="C-迭代器"><a href="#C-迭代器" class="headerlink" title="C#迭代器"></a>C#迭代器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>程序设计的<a href="https://baike.baidu.com/item/软件设计模式/2117635" target="_blank" rel="noopener">软件设计模式</a>，可在容器（container，例如<a href="https://baike.baidu.com/item/链表/9794473" target="_blank" rel="noopener">链表</a>或<a href="https://baike.baidu.com/item/阵列/2644035" target="_blank" rel="noopener">阵列</a>）上遍访的接口，设计人员无需关心容器的内容。<a href="https://baike.baidu.com/item/迭代器/3803342?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
<ul>
<li>迭代器是产生值的有序序列的一个语句块。是实现函数成员的方式。</li>
<li>迭代器块在C#语法中不是独特的元素，它们在几个方面受到限制，并且主要作用在函数成员声明的语义上，它们在语法上只是语句块而已。</li>
</ul>
<h5 id="IEnumeraber-IEnumerator"><a href="#IEnumeraber-IEnumerator" class="headerlink" title="IEnumeraber IEnumerator"></a>IEnumeraber IEnumerator</h5><p><a href="https://www.cnblogs.com/w-wfy/p/7418464.html" target="_blank" rel="noopener">C# IEnumerator的详解</a></p>
<p>其他详见 Unity脚本编程-第八章</p>
<p><img src="../images/corountine_1.png" alt="corountine_1"></p>
<p>####糖块yield</p>
<p>yield 关键字向编译器指示它所在的方法是迭代器块</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>将当前集合中的元素立即返回</p>
<ul>
<li>yield return  返回元素</li>
<li>yield break   终止迭代</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>返回类型必须为 IEnumerable、IEnumerable<t>、IEnumerator 或 IEnumerator<t></t></t></li>
<li>参数前不能使用ref和out关键字</li>
<li>匿名方法中 不能使用yield</li>
<li>unsef中不能使用</li>
<li>yield return 不能置于 try-catch 块中。 可置于 try-finally 语句的 try 块中。   yield break   能 try 块或 catch 块，        不置于 finally 块</li>
</ul>
<h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>编程语言Lua从5.0版开始支持协程的概念，极大的扩展了Lua的能力。<a href="https://baike.baidu.com/item/Lua/7570719" target="_blank" rel="noopener">Lua</a>的协程通过扩展库coroutine来实现，其中的所有函数如下（具体可以参考Lua的官方manual）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`coroutine.create``coroutine.resume``coroutine.running``coroutine.status``coroutine.wrap``coroutine.yield`</span><br></pre></td></tr></table></figure>

<p>当前运行的代码可以看作运行在主协程中（就像C程序的main运行在主线程中），通过create可以创建一个协程，<a href="https://baike.baidu.com/item/resume/8876788" target="_blank" rel="noopener">resume</a>以运行此协程，直到新协程调用<a href="https://baike.baidu.com/item/yield/3824119" target="_blank" rel="noopener">yield</a>程序才能返回到”主协程“中运行。</p>
<p><strong>coroutine.create()</strong></p>
<p><strong>函数参数：</strong>接收单个参数，该参数是coroutine的主函数，即resume会执行的函数</p>
<p><strong>函数返回值：</strong>返回其控制器，一个对象为thread的对象</p>
<p><strong>函数作用：</strong>creat函数创建一个新的coroutine，定义了协程内的任务流程。从面对对象的角度来看，可以看成是coroutine类创建了一个对象co</p>
<p><strong>coroutine.resume(co,[val1,val2,…])</strong></p>
<p><strong>函数参数：</strong>第一个参数即creat的返回值，一个thread对象。第二个参数是coroutine中执行需要的参数，是一个变长参数，可以传入任意多个。</p>
<p><strong>函数返回值：</strong>当程序运行没有错误的时候，返回true，同时返回前一个调用coroutine.yield中传入的参数。如果有错误，返回错误false以及错误信息。</p>
<p><strong>函数作用：</strong>当第一次调用coroutine的resume方法的时候，其从主函数第一行开始执行，之后再coroutine开始运行后，它会一直运行到自身终止或者是coroutine的下一个yield函数。</p>
<p><strong>coroutine.yield(…)</strong></p>
<p><strong>函数参数：</strong>传入变长参数</p>
<p><strong>函数返回值：</strong>返回在前一个resume中传入的参数值</p>
<p><strong>函数作用：</strong>挂起当前的执行协程。该协程不能是一个C函数，一个元表或一个迭代器</p>
<p><strong>coroutine.running()：</strong>返回当前正在执行的协程</p>
<p><strong>coroutine.status()：</strong>返回当前协程的状态，有running/suspended/normal/dead等。</p>
<h3 id="Unity协程实现"><a href="#Unity协程实现" class="headerlink" title="Unity协程实现"></a>Unity协程实现</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><a href="https://blog.csdn.net/qq_16054639/article/details/80151445" target="_blank" rel="noopener">Unity脚本编程</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1437157" target="_blank" rel="noopener">生命周期</a></p>
<p>​        通过设置MonoBehaviour脚本的enabled对协程是没有影响的，但如果 gameObject.SetActive(false) 则已经启动的协程则完全停止了，即使在Inspector把gameObject 激活还是没有继续执行。也就说协程虽然是在MonoBehvaviour启动的（StartCoroutine）但是协程函数的地位完全是跟MonoBehaviour是一个层次的，不受MonoBehaviour的状态影响，但跟MonoBehaviour脚本一样受gameObject 控制，也应该是和MonoBehaviour脚本一样每帧“轮询” yield 的条件是否满足。</p>
<p>####开启函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StartCoroutine(Test_00()); // IEnumerator</span><br><span class="line">StartCoroutine(&quot;Test_01&quot;);</span><br><span class="line">StartCoroutine(Test_02(5, 9));</span><br></pre></td></tr></table></figure>

<h4 id="终止函数"><a href="#终止函数" class="headerlink" title="终止函数"></a>终止函数</h4><ul>
<li>StopCoroutine(“<strong>name</strong>“)</li>
<li>StopAllCoroutines</li>
</ul>
<ol>
<li><p>它们只能终止改MonoBehaviour中的协程</p>
</li>
<li><p>还有一种方法可以终止协同程序，即将协同程序所在gameobject的active属性设置为false，当再次设置active为ture时，协同程序并不会再开启；如是将协同程序所在脚本的enabled设置为false则不会生效。-原因见上面</p>
</li>
</ol>
<p><a href="http://www.xuanyusong.com/archives/1427" target="_blank" rel="noopener">雨松momo</a></p>
<p>####yield</p>
<p>yield return 0 or yield return null:程序在下一帧中从当前位置继续执行</p>
<p>yield return 1,2,3,……: 程序等待1，2，3…帧之后从当前位置继续执行</p>
<p>yield return new WaitForSeconds(n):程序等待n秒后从当前位置继续执行</p>
<p>yield new WaitForEndOfFrame():在所有的渲染以及GUI程序执行完成后从当前位置继续执行</p>
<p>yield new WaitForFixedUpdate():所有脚本中的FixedUpdate()函数都被执行后从当前位置继续执行</p>
<p>yield return WWW:等待一个网络请求完成后从当前位置继续执行</p>
<p>yield return StartCoroutine():等待一个协程执行完成后从当前位置继续执行</p>
<p>true</p>
<p>False</p>
<p>备注：曾经尝试在协程中加入停止后从新启用的功能，怕是个智障。</p>
<p>Bool isTodo;</p>
<p>ie test（）{</p>
<p>​    while(isTodo){</p>
<p>​    }</p>
<p>yiled return </p>
<p>Do Fun();</p>
<p>}</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>协程</tag>
        <tag>语法糖</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>构造和析构</title>
    <url>/2019/08/01/%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<p><strong>派生类构造函数执行的次序</strong>：</p>
<ol>
<li><p>调用<strong>基类构造</strong>函数，调用顺序按照它们 被继承时声明的顺序 （<strong>从左到右</strong>）；</p>
</li>
<li><p>调用<strong>内嵌成员对象</strong>的构造函数，调用顺序按照它们在类中声明的顺序；</p>
</li>
<li><p>派生类自己构造函数体中的内容。</p>
</li>
</ol>
<p><strong>派生类析构函数执行的次序</strong>：<br>派生类的析构函数的功能是在该对象消亡之前进行一些必要的清理工作，析构函数没有类型，也没有参数。</p>
<p>析构函数的执行顺序与构造函数相反。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>析构</tag>
      </tags>
  </entry>
  <entry>
    <title>FSM有限状态机</title>
    <url>/2019/08/01/FSM%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>了解FSM之前需要了解一下状态机</p>
<p>FSM是状态机的一种实现方式，它把复杂的控制逻辑分解成有限个稳定状态，在每个状态上判断事件，变连续处理为离散数字。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>发生事件(event)后，根据当前状态(cur_state) ，决定执行的动作(action)，并设置下一个状态号(nxt_state)。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>有限</li>
<li>状态离散性</li>
</ul>
<p>因为有限状态机是个封闭系统，具有结束状态，所以它是有限的。</p>
<p>状态离散性：离散的某一时刻只能处于某种状态之下，且需要满足某种条件才能从一种状态转移到另一种状态。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>状态机的设计状态之间的关系是一个麻烦的事情，所以在设计的过程中需要借助状态图或者状态表来设计。</p>
<p>个人喜欢现态/次态表，其中填写事件和动作，然后将条件梳理。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>FSM实现事件检测可以通过“轮询”或者“事件驱动”的方式。下面代码是采用轮询的方式。</p>
<p>这是一本书中提到的<a href="http://wiki.unity3d.com/index.php?title=Finite_State_Machine" target="_blank" rel="noopener">通用FSM状态机源码 </a>其中包括了1.Description 2.Component 3.C#-FSMSystem.cs 4.Example。</p>
<p>部分代码展示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Transition</span><br><span class="line">&#123;</span><br><span class="line">    NullTransition = 0,</span><br><span class="line">&#125;</span><br><span class="line"> public enum StateID</span><br><span class="line">&#123;</span><br><span class="line">    NullStateID = 0,</span><br><span class="line">&#125;</span><br><span class="line"> public abstract class FSMState</span><br><span class="line">&#123;</span><br><span class="line">    protected Dictionary&lt;Transition, StateID&gt; map = new Dictionary&lt;Transition, StateID&gt;();</span><br><span class="line">    protected StateID stateID;</span><br><span class="line">    public StateID ID &#123; get &#123; return stateID; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    public void AddTransition(Transition trans, StateID id)&#123;&#125;</span><br><span class="line">    public void DeleteTransition(Transition trans)&#123;&#125;</span><br><span class="line">    public StateID GetOutputState(Transition trans)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public virtual void DoBeforeEntering() &#123; &#125;</span><br><span class="line">    public virtual void DoBeforeLeaving() &#123; &#125; </span><br><span class="line"></span><br><span class="line">    public abstract void Reason(GameObject player, GameObject npc);</span><br><span class="line">    public abstract void Act(GameObject player, GameObject npc);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class FSMSystem</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;FSMState&gt; states;</span><br><span class="line">    private StateID currentStateID;</span><br><span class="line">    public StateID CurrentStateID &#123; get &#123; return currentStateID; &#125; &#125;</span><br><span class="line">    private FSMState currentState;</span><br><span class="line">    public FSMState CurrentState &#123; get &#123; return currentState; &#125; &#125;</span><br><span class="line">    public FSMSystem()</span><br><span class="line">    &#123;</span><br><span class="line">       states = new List&lt;FSMState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void AddState(FSMState s)&#123;&#125;</span><br><span class="line">    public void DeleteState(StateID id)&#123;&#125;</span><br><span class="line">    public void PerformTransition(Transition trans)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点</li>
<li>缺点</li>
</ul>
<p>优点：相对简单的状态机来使用swich那样不方便扩展，将事件放置具体状态中相对来说好维护</p>
<p>缺点：1.随着状态的增加我们会发现有很多相似的状态 2.随着状态的增多，维护链接成本还是很高的 3.很难做到状态并行 </p>
<p>下图是我画的状态图</p>
<p>它的表现效果是双方士兵们出阵然后开始群殴，直至一方士兵全部死亡。当时并没有采用现态/次态表，很遗憾很乱，而且事件条件很乱很有可以会出错。如果这时候策划来说，我感觉一方敌人全部死亡之后，呆呆的站在那里很难受，让他们庆祝一下吧。这时候我很方便的添加一个庆祝状态，庆祝之后站立。</p>
<p>它状态少的时候还好，状态多的时候就很尴尬，维护起来的成本很高。而且无法达到并行的目的。而且出阵和冲锋其实有点相似的。状态机的确满足了我的项目需求，但是不可否认的是FSM本身存在的问题，不过相比BT(行为树)自顶向下的轮询方式，它起码可以采用事件驱动的方式来实现状态切换，而且在针对简单的项目需求还是蛮有效的，所以在游戏开发中需要根据具体情况去合理的在状态机和BT之间权衡。然后采用适合自己的项目的方式实现，如下面的扩展。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li>分层状态机</li>
<li>并行状态机</li>
<li>BT行为树</li>
<li>神经网络</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>FSM</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>windows-屏幕阅读器</title>
    <url>/2019/07/31/windows-%E5%B1%8F%E5%B9%95%E9%98%85%E8%AF%BB%E5%99%A8/</url>
    <content><![CDATA[<p>莫名开启的讲述人功能</p>
<p>快捷键开启 ctr + window + Enter</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/2019/07/27/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>状态机：描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应的模型。</p>
<p>用来表示有限多个状态以及在这些状态（State）之间转移（Transition）和动作（Action）的数学模型。</p>
<p>简单的说它可以<strong>将单位的所有行为去划分状态，状态与状态之间通过事件的触发形成。</strong></p>
<p><strong>状态机可归纳为4个要素，即现态，条件，动作，次态。</strong></p>
<ul>
<li>现态：是指当前所处的状态。</li>
<li>条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li>
<li>动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。<strong>动作不是必需的</strong></li>
<li>次态：条件满足后要迁往的新状态。</li>
</ul>
<p>事件：1.检测转换条件 2.进行状态切换</p>
<h2 id="设计状态机"><a href="#设计状态机" class="headerlink" title="设计状态机"></a>设计状态机</h2><ul>
<li>可以用状态移动图表示</li>
<li>可以用表格来表示，如：事件/状态表，现态/次态表…</li>
</ul>
<p>AI设计中个人喜欢现态/次态表</p>
<p><img src="https://img-blog.csdnimg.cn/20190715014012283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="状态机分类"><a href="#状态机分类" class="headerlink" title="状态机分类"></a>状态机分类</h2><ul>
<li>Moore状态机：输出只和状态有关而与输入无关</li>
<li>Mealy状态机：输出不仅和状态有关而且和输入有关系</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>竖向：swich，if..else</li>
<li>横向：FSM </li>
</ul>
<h2 id="附录：竖向写"><a href="#附录：竖向写" class="headerlink" title="附录：竖向写"></a>附录：竖向写</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cur_state = nxt_state;</span><br><span class="line"></span><br><span class="line">switch(cur_state)&#123; //在当前状态中判断事件</span><br><span class="line"></span><br><span class="line">case s0: //在s0状态</span><br><span class="line"></span><br><span class="line">if(e0_event)&#123; //如果发生e0事件，那么就执行a0动作，</span><br><span class="line"></span><br><span class="line">并保持状态不变；</span><br><span class="line"></span><br><span class="line">执行a0动作;</span><br><span class="line"></span><br><span class="line">//nxt_state = s0; //因为状态号是自身，所以可以删除此句</span><br><span class="line"></span><br><span class="line">，以提高运行速度。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if(e1_event)&#123; //如果发生e1事件，那么就执行a1动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s1态；</span><br><span class="line"></span><br><span class="line">执行a1动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if(e2_event)&#123; //如果发生e2事件，那么就执行a2动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s2态；</span><br><span class="line"></span><br><span class="line">执行a2动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case s1: //在s1状态</span><br><span class="line"></span><br><span class="line">if(e2_event)&#123; //如果发生e2事件，那么就执行a2动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s2态；</span><br><span class="line"></span><br><span class="line">执行a2动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case s2: //在s2状态</span><br><span class="line"></span><br><span class="line">if(e0_event)&#123; //如果发生e0事件，那么就执行a0动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s0态；</span><br><span class="line"></span><br><span class="line">执行a0动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>FSM</tag>
        <tag>状态机</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度，空间复杂度和稳定性</title>
    <url>/2019/07/26/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<p>时间复杂度，空间复杂度和稳定性</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>指的是算法执行语句的次数（取最多次数的那个语句来表示）<br><img src="https://img-blog.csdnimg.cn/20190721132322442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>a^x^ =N（a&gt;0，且a≠1） ==&gt; x=log<del>a</del>N<br>注： Hash的查找的时间复杂度是1，原因“key-value键值对”，离散的</p>
<p>下面是3个例子关于while简单的理解一下时间复杂度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一个算法执行次数是20，常量所以是O(1)</span><br><span class="line">int x = 1;</span><br><span class="line">while (x&lt;20)</span><br><span class="line">&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二个执行次数是n决定，O(n)</span><br><span class="line">int x = 1;</span><br><span class="line">while (x&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行次数由 c 和 n共同决定，c = 1 时，O(1)，c != 1时，O(n)</span><br><span class="line">int x = 1;</span><br><span class="line">c = c or 1;</span><br><span class="line">while (x&lt;n &amp;&amp; c != 1)</span><br><span class="line">&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个简单插入排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 分类 ------------- 内部比较排序</span><br><span class="line">// 数据结构 ---------- 数组</span><br><span class="line">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span><br><span class="line">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span><br><span class="line">// 平均时间复杂度 ---- O(n^2)</span><br><span class="line">// 所需辅助空间 ------ O(1)</span><br><span class="line">// 稳定性 ------------ 稳定</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;;// 从小到大插入排序</span><br><span class="line">    int n = sizeof(A) / sizeof(int);</span><br><span class="line">    int i, j, get;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; n; i++)             // 类似抓扑克牌排序</span><br><span class="line">    &#123;</span><br><span class="line">        get = A[i];                     // 右手抓到一张扑克牌</span><br><span class="line">        j = i - 1;                      // 拿在左手上的牌总是排序好的</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; A[j] &gt; get)    // 将抓到的牌与手牌从右向左进行比较</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + 1] = A[j];            // 如果该手牌比抓到的牌大,就将其右移</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + 1] = get;// 直到该手牌比抓到的牌小(或二者相等),将抓到的牌插入到该手牌右边(相等元素的相对次序未变,所以插入排序是稳定的)</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;插入排序结果：&quot;);</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进一下，第二层采用二分查找法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 分类 -------------- 内部比较排序</span><br><span class="line">// 数据结构 ---------- 数组</span><br><span class="line">// 最差时间复杂度 ---- O(n^2)</span><br><span class="line">// 最优时间复杂度 ---- O(nlogn)</span><br><span class="line">// 平均时间复杂度 ---- O(n^2)</span><br><span class="line">// 所需辅助空间 ------ O(1)</span><br><span class="line">// 稳定性 ------------ 稳定</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大二分插入排序</span><br><span class="line">    int n = sizeof(A) / sizeof(int);</span><br><span class="line">    int i, j, get, left, right, middle;</span><br><span class="line">    </span><br><span class="line">    for (i = 1; i &lt; n; i++)                 // 类似抓扑克牌排序</span><br><span class="line">    &#123;</span><br><span class="line">        get = A[i];                         // 右手抓到一张扑克牌</span><br><span class="line">        left = 0;                           // 拿在左手上的牌总是排序好的,所以可以用二分法</span><br><span class="line">        right = i - 1;                      // 手牌左右边界进行初始化</span><br><span class="line">        while (left &lt;= right)               // 采用二分法定位新牌的位置</span><br><span class="line">        &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (A[middle] &gt; get)</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            else</span><br><span class="line">                left = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = i - 1; j &gt;= left; j--)    // 将欲插入新牌位置右边的牌整体向右移动一个单位</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + 1] = A[j];            </span><br><span class="line">        &#125;</span><br><span class="line">        A[left] = get;                    // 将抓到的牌插入手牌</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;二分插入排序结果：&quot;);</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改进一下，成为希尔排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line"></span><br><span class="line">// 分类 -------------- 内部比较排序</span><br><span class="line">// 数据结构 ---------- 数组</span><br><span class="line">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span><br><span class="line">// 最优时间复杂度 ---- O(n)</span><br><span class="line">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span><br><span class="line">// 所需辅助空间 ------ O(1)</span><br><span class="line">// 稳定性 ------------ 不稳定</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大希尔排序</span><br><span class="line">    int n = sizeof(A) / sizeof(int);</span><br><span class="line">    int i, j, get;</span><br><span class="line">    int h = 0;</span><br><span class="line">    while (h &lt;= n)                          // 生成初始增量</span><br><span class="line">    &#123;</span><br><span class="line">        h = 3*h + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (h &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = h; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i - h;</span><br><span class="line">            get = A[i];</span><br><span class="line">            while ((j &gt;= 0) &amp;&amp; (A[j] &gt; get))</span><br><span class="line">            &#123;</span><br><span class="line">                A[j + h] = A[j];</span><br><span class="line">                j = j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + h] = get;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h - 1) / 3;                    // 递减增量</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;希尔排序结果：&quot;);</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>指对一个算法在运行过程中临时占用存储空间，看你开辟的临时空间就好了。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><h3 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h3><p>指的是针对相同数值，在排序前后是否有发生变化的可能。一般举返例来证明</p>
<blockquote>
<p>这只是一个例子来说明稳定性，大家普遍说冒泡是稳定的，条件换成“&gt;=”导致算法不稳定，建议不要</p>
</blockquote>
<p>下面是个简单冒泡排序来排序｛1，1，1，1，1，1，2， 2，1｝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int j = 0; j &lt; n - 1; j++)           </span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; n - 1 - j; i++)   </span><br><span class="line">        &#123;</span><br><span class="line">            if (A[i] &gt; A[i + 1])            // 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法</span><br><span class="line">            &#123;</span><br><span class="line">                exchange(A, i, i + 1);        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值稳定性"><a href="#数值稳定性" class="headerlink" title="数值稳定性"></a>数值稳定性</h3><p>讨论的是计算机编程中，由于四舍五入等导致的结果偏差。</p>
<ul>
<li>尽量减少运算次数</li>
<li>加法运算时，避免大数加小数</li>
<li>避免两个相近的数相减</li>
<li>避免小数做除法或者大数做乘法</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="常见排序总结"><a href="#常见排序总结" class="headerlink" title="常见排序总结"></a>常见排序总结</h3><p><img src="https://img-blog.csdnimg.cn/20190721132409247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://www.cnblogs.com/hubgit/p/6743513.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">编程排序算法</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
