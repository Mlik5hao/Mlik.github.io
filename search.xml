<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HexoNext添加搜索功能</title>
    <url>/2019/12/01/HexoNext%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h4 id="安装相关插件"><a href="#安装相关插件" class="headerlink" title="安装相关插件"></a>安装相关插件</h4><p>安装搜索插件： <code>hexo-generator-searchdb</code></p><p>在博客根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><h4 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h4><p>安装完成，编辑博客配置文件：<code>_config.yml</code></p><a id="more"></a>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>Next 主题自带搜索设置，编辑主题配置文件：<code>_config.yml</code></p>
<p>找到文件中 Local search 的相关配置，设为 <code>true</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>hexo 重新部署</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity2D精灵阴影问题</title>
    <url>/2019/11/30/Unity2D%E7%B2%BE%E7%81%B5%E9%98%B4%E5%BD%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">[RequireComponent(typeof(SpriteRenderer))]</span><br><span class="line">public class SpriteShadow : MonoBehaviour&#123;</span><br><span class="line">    [HideInInspector]</span><br><span class="line">	public Vector2 offset;</span><br><span class="line">	public float offsetX;</span><br><span class="line">	public float offsetY;</span><br><span class="line">	private SpriteRenderer sprRndCaster;</span><br><span class="line">	private SpriteRenderer sprRndShadow;</span><br><span class="line">	private Transform transCaster;</span><br><span class="line">	private Transform transShadow;</span><br><span class="line">    [HideInInspector]</span><br><span class="line">    public Material ShadowMaterial;</span><br><span class="line">    [Tooltip(&quot;Order in Layer&quot;)]</span><br><span class="line">    //public int sortingOrder;</span><br><span class="line">    public int sortingOrderDifference;</span><br><span class="line"></span><br><span class="line">    //public int sortingOrderDifference;</span><br><span class="line">    //public bool updateSpriteOverTime = true;</span><br><span class="line">    public bool updatePositionOverTime = true;</span><br><span class="line">    private void Start()&#123;</span><br><span class="line">		this.offset = new Vector2(this.offsetX, this.offsetY);</span><br><span class="line">		this.transCaster = this.transform;</span><br><span class="line">		this.transShadow = new GameObject().transform;</span><br><span class="line">		this.transShadow.parent = this.transCaster;</span><br><span class="line">		this.transShadow.gameObject.name = &quot;Shadow&quot;;</span><br><span class="line">		this.transShadow.localRotation = Quaternion.identity;</span><br><span class="line">		var vector = Vector3.one;</span><br><span class="line">		var parent = this.transShadow;</span><br><span class="line">		while (parent != null)&#123;</span><br><span class="line">            //vector.Multiply(parent.localScale);  //  放大 x * x， y * y</span><br><span class="line">            parent = parent.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		this.transShadow.localScale = vector;</span><br><span class="line">		this.sprRndCaster = this.GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">        this.sprRndShadow = this.transShadow.gameObject.AddComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">        //this.sprRndShadow.material = this.ShadowMaterial;</span><br><span class="line">        this.sprRndShadow.material = this.sprRndCaster.material;</span><br><span class="line">        //HHLogger.DEBUG(this.ShadowMaterial, this.sprRndCaster.material);</span><br><span class="line">        this.sprRndShadow.material.color = new Color(1,1,1,0.35f);</span><br><span class="line">		//this.sprRndShadow.color = Color.white;</span><br><span class="line">        this.sprRndShadow.color = Color.black;</span><br><span class="line">        this.sprRndShadow.sortingLayerName = this.sprRndCaster.sortingLayerName;</span><br><span class="line">        this.sprRndShadow.sortingOrder = this.sprRndCaster.sortingOrder + this.sortingOrderDifference - 1;</span><br><span class="line">        this.transShadow.position = new Vector2(this.transCaster.position.x + this.offset.x, this.transCaster.position.y + this.offset.y);</span><br><span class="line">        //this.transShadow.localPosition = new Vector3(this.offset.x, this.offset.y, 0);</span><br><span class="line">        this.sprRndShadow.sprite = this.sprRndCaster.sprite;</span><br><span class="line">        this.sprRndShadow.flipX = this.sprRndCaster.flipX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void LateUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        //if (this.updateSpriteOverTime)&#123;</span><br><span class="line">        //	this.sprRndShadow.sprite = this.sprRndCaster.sprite;</span><br><span class="line">        //	this.sprRndShadow.flipX = this.sprRndCaster.flipX;</span><br><span class="line">        //&#125;</span><br><span class="line">        if (this.updatePositionOverTime)</span><br><span class="line">        &#123;</span><br><span class="line">            this.transShadow.position = new Vector2(this.transCaster.position.x + this.offset.x, this.transCaster.position.y + this.offset.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>精灵</tag>
        <tag>阴影</tag>
      </tags>
  </entry>
  <entry>
    <title>C#文件处理</title>
    <url>/2019/11/26/C-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title>C#数据处理</title>
    <url>/2019/11/26/C-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>LuaTable拷贝</title>
    <url>/2019/11/26/LuaTable%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h5 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowcopy</span><span class="params">(orig)</span></span></span><br><span class="line">    <span class="keyword">local</span> orig_type = <span class="built_in">type</span>(orig)</span><br><span class="line">    <span class="keyword">local</span> copy</span><br><span class="line">    <span class="keyword">if</span> orig_type == <span class="string">'table'</span> <span class="keyword">then</span></span><br><span class="line">        copy = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> orig_key, orig_value <span class="keyword">in</span> <span class="built_in">pairs</span>(orig) <span class="keyword">do</span></span><br><span class="line">            copy[orig_key] = orig_value</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">-- number, string, boolean, etc</span></span><br><span class="line">        copy = orig</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<h5 id="DeepCopy"><a href="#DeepCopy" class="headerlink" title="DeepCopy"></a>DeepCopy</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepcopy</span><span class="params">(orig)</span></span></span><br><span class="line">    <span class="keyword">local</span> orig_type = <span class="built_in">type</span>(orig)</span><br><span class="line">    <span class="keyword">local</span> copy</span><br><span class="line">    <span class="keyword">if</span> orig_type == <span class="string">'table'</span> <span class="keyword">then</span></span><br><span class="line">        copy = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> orig_key, orig_value <span class="keyword">in</span> <span class="built_in">next</span>, orig, <span class="literal">nil</span> <span class="keyword">do</span></span><br><span class="line">            copy[deepcopy(orig_key)] = deepcopy(orig_value)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">setmetatable</span>(copy, deepcopy(<span class="built_in">getmetatable</span>(orig)))</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">-- number, string, boolean, etc</span></span><br><span class="line">        copy = orig</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepcopy</span><span class="params">(orig, copies)</span></span></span><br><span class="line">    copies = copies <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> orig_type = <span class="built_in">type</span>(orig)</span><br><span class="line">    <span class="keyword">local</span> copy</span><br><span class="line">    <span class="keyword">if</span> orig_type == <span class="string">'table'</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> copies[orig] <span class="keyword">then</span></span><br><span class="line">            copy = copies[orig]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            copy = &#123;&#125;</span><br><span class="line">            copies[orig] = copy</span><br><span class="line">            <span class="built_in">setmetatable</span>(copy, deepcopy(<span class="built_in">getmetatable</span>(orig), copies))</span><br><span class="line">            <span class="keyword">for</span> orig_key, orig_value <span class="keyword">in</span> <span class="built_in">next</span>, orig, <span class="literal">nil</span> <span class="keyword">do</span></span><br><span class="line">                copy[deepcopy(orig_key, copies)] = deepcopy(orig_value, copies)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">-- number, string, boolean, etc</span></span><br><span class="line">        copy = orig</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 见链接二https://gist.github.com/Deco/<span class="number">3985043</span></span><br></pre></td></tr></table></figure>

<p><a href="http://lua-users.org/wiki/CopyTable" target="_blank" rel="noopener">http://lua-users.org/wiki/CopyTable</a></p>
<p><a href="https://gist.github.com/Deco/3985043" target="_blank" rel="noopener">https://gist.github.com/Deco/3985043</a></p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>LuaTable判空</title>
    <url>/2019/11/25/LuaTable%E5%88%A4%E7%A9%BA/</url>
    <content><![CDATA[<p><strong>Lua判断表为空t = {}的逻辑</strong></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">next</span>(a) == <span class="literal">nil</span> <span class="keyword">then</span></span><br></pre></td></tr></table></figure><p><strong>next(table[,index])</strong></p><blockquote>
<p>运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 <code>next</code> 返回该键的下一个键及其关联的值。 如果用 <strong>nil</strong> 作为第二个参数调用 <code>next</code> 将返回初始键及其关联值。 当以最后一个键去调用，或是以 <strong>nil</strong> 调用一张空表时， <code>next</code> 返回 <strong>nil</strong>。 如果不提供第二个参数，将认为它就是 <strong>nil</strong>。 特别指出，你可以用 <code>next(t)</code> 来判断一张表是否是空的。</p>
<p>索引在遍历过程中的次序无定义， <em>即使是数字索引也是这样</em>。 （如果想按数字次序遍历表，可以使用数字形式的 <strong>for</strong> 。） -Lua 5.3参考手册</p>
</blockquote><a id="more"></a>




<p><strong>(转)</strong>在项目的脚本lua中经常有这样的需求，</p>
<p>1、local a = {}</p>
<p>2、对a进行处理</p>
<p>3、对a是否为空表进行判断</p>
<p>关于对a是否为空表的判断，如果直接这样做：</p>
<p>if a == {} then</p>
<p>这样的结果就是a == {}永远返回false，是一个逻辑错误。因为这里比较的是table a和一个匿名table的内存地址。</p>
<p>也有些代码如此做：</p>
<p>if table.maxn(a) == 0 then</p>
<p>这样做也不保险，除非table的key都是数字，而没有hash部分。</p>
<p>难道真的要遍历table发现有东西就return false跳出才能断定它是否为空吗？这样做是可以的，至少目前项目中前人是这么封装的，不过代码太难看. </p>
<p>网上小搜了一下，发现原来官方手册里早已经给了答案，那就是靠lua内置的next函数</p>
<p>即如此用：if next(a) == nil then</p>
<p>next其实就是pairs遍历table时用来取下一个内容的函数.</p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>LuaTable函数库</title>
    <url>/2019/11/25/LuaTable%E5%87%BD%E6%95%B0%E5%BA%93/</url>
    <content><![CDATA[<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">table</span>,[ pos,] value) </span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">table</span>[, pos]) </span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">concat</span>(<span class="built_in">table</span>[, sep[, i[, j]]]) </span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(<span class="built_in">table</span>[, comp]) // 见Lua排序</span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">getn</span>() //<span class="number">5.0</span>费</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">maxn</span>() //<span class="number">5.2</span>费</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>#####insert, remove</p>
<p>insert 和 remove 只能用于数组元素的插入和移出， 进行插入和移出时，会将后面的元素对齐起来。<br>  所以在 for 循环中进行 insert 和 remove 的时候要注意插入和移除时是否<strong>漏掉</strong>了某些项：<br>    local t = {1,2,3,3,5,3,6}<br>    for i,v in ipairs(t) do<br>      if v == 3 then<br>        table.remove(t,i)<br>      end<br>    end<br>    – 错误，第四个 3 没有被移除，ipairs 内部会维护一个变量记录遍历的位置，remove 掉第三个数字 3 之后，ipairs 下一个返回的值是 5 而不是 3 </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125; </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, #t <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> t[i] == <span class="number">3</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">remove</span>(t,i) </span><br><span class="line">    i = i<span class="number">-1</span> </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="comment">-- 错误，i=i-1 这段代码没有用，i 的值始终是从 1 到 #t，for 循环里修改 i 的值不起作用 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125; </span><br><span class="line"><span class="keyword">for</span> i=#t, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> t[i] == <span class="number">3</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">remove</span>(t,i) </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="comment">-- 正确，从后往前遍历 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125; </span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> t[i] <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> t[i] == <span class="number">3</span> <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">remove</span>(t,i) </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    i = i+<span class="number">1</span> </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="comment">-- 正确，自己控制 i 的值是否增加</span></span><br></pre></td></tr></table></figure>

<h5 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h5><p>concat 可以将 table 的数组部分拼接成一个字符串，中间用 seq 分隔。<br>  lua 中字符串的存储方式与 C 不一样，lua 中的每个字符串都是单独的一个拷贝，拼接两个字符串会产生一个新的拷贝，如果拼接操作特别多，就会影响性能：<br>    local beginTime = os.clock()<br>    local str = “”<br>    for i=1, 30000 do<br>      str = str .. i<br>    end<br>    local endTime = os.clock()<br>    print(endTime - beginTime)<br>    – 消耗 0.613 秒，产生了 30000 个字符串拷贝，但只有最后一个是有用的</p>
<p>​    local beginTime = os.clock()<br>​    local t = {}<br>​    for i=1, 30000 do<br>​      t[i] = i<br>​    end<br>​    local str = table.concat(t, “”)<br>​    local endTime = os.clock()<br>​    print(endTime - beginTime)<br>​    – 消耗 0.024 秒，利用 concat，一次性把字符串拼接出来，只产生了一个字符串拷贝 </p>
<h5 id="maxn"><a href="#maxn" class="headerlink" title="maxn"></a>maxn</h5><ul>
<li>原型：table.maxn (tab_table)</li>
<li>解释：返回一个表<code>tab_table</code>中的最大正数索引，如果没有正数索引的话返回0。</li>
<li>总结#<ul>
<li>这个函数比较简单，行为和函数解释一致，<strong>不要求索引必须连续，返回一个最大的正数索引</strong>。</li>
<li>有运行结果可知，当表中<strong>只有</strong>非数字索引或者负数索引时，函数返回0。</li>
<li>其中官方文档中有一句话，大意是说这个函数的工作原理就是线性的遍历了这个表</li>
</ul>
</li>
</ul>
<p><a href="https://www.cnblogs.com/whiteyun/archive/2009/08/10/1543139.html" target="_blank" rel="noopener">https://www.cnblogs.com/whiteyun/archive/2009/08/10/1543139.html</a></p>
<p><a href="https://www.cnblogs.com/slysky/p/5360387.html" target="_blank" rel="noopener">https://www.cnblogs.com/slysky/p/5360387.html</a></p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>table函数</tag>
        <tag>maxn</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2019/11/20/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>读书</category>
        <category>CLR via C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>笔记</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>CLR的执行模型</title>
    <url>/2019/11/19/CLR%E7%9A%84%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C#</category>
        <category>读书</category>
        <category>CLR via C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>委托</title>
    <url>/2019/11/18/%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h5 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h5><p>是对方法的引用。本质类。</p><blockquote>
<p>委托是类型安全的：只能让委托引用与委托签名匹配的方法。</p>
<p>派生自System.MulticastDelegate(派生自System.Delegate)</p>
</blockquote><p>定义后，创建实例初始化</p><a id="more"></a>


<ul>
<li>显式初始化 </li>
<li>在用+=等时自动初始化</li>
</ul>
<blockquote>
<p>未初始化 抛出异常NullReferenException</p>
</blockquote>
<h5 id="内置"><a href="#内置" class="headerlink" title="内置"></a>内置</h5><ul>
<li>Func&lt;&gt;    返回值，最后一个参数是返回值</li>
<li>Action&lt;&gt; 无返回值</li>
<li>匿名方法 delegate(){}</li>
<li>Lambda表达式()=&gt;{}， x =&gt; return x;</li>
</ul>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>类的成员。 </p>
<blockquote>
<p>公共事件只能在定义它的那个类中的方法引发。在类外部引用会造成编译时错误。</p>
<p>记得判null。</p>
</blockquote>
<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>作为两个不兼容的接口之间的桥梁</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>笔记</tag>
        <tag>委托</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的定制特性</title>
    <url>/2019/11/18/Unity%E4%B8%AD%E7%9A%84%E5%AE%9A%E5%88%B6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>C#特性</p>
<p>Unity特性</p>
</blockquote><h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><p>C#特性从本质上来说，自定义特性是一个标签。编译器会在托管模块的元数据中嵌入这些额外的信息。大多数的特性对编译器来说并没有意义，编译器只是机械的检测源码中的特性，并生成对应的元数据。</p><a id="more"></a>

<p>特性其实是一个类型的实例，特性类必须有公共构造用于实例化一个实例。就像<code>[DllImport(&quot;PluginName&quot;)]</code></p>
<p>所有特性直接或者间接的派生于<strong>System.Attribut</strong>，这样符合CLS(Common Language Specification)中关于特性的需求。</p>
<p><strong>Dllmpot特性</strong></p>
<p><strong>Serializable特性</strong></p>
<h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p>Unity中的特性类定义在两个命名空间中- UnityEngine和UnityEditor。同样它们符合CLS。</p>
<h2 id="定义自己的特性类"><a href="#定义自己的特性类" class="headerlink" title="定义自己的特性类"></a>定义自己的特性类</h2><p>自定义的特性用<strong>基础库中的定义的特性类（System.AttributeAttribute）</strong>限制特性的适用范围。</p>
<p>检测特性。</p>
<p><img src="/Users/mlikeryour/Desktop/hexo/source/images/%E7%89%B9%E6%80%A7.png" alt="特性"></p>
<p>备注：</p>
<p>1.整理之前自己用到的C#特性与Unity特性。</p>
<p>2.整理之前写的Unity编辑器扩展。</p>
]]></content>
      <categories>
        <category>读书</category>
        <category>Unity</category>
        <category>Unity3D脚本编程</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#特性</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>从序列化和反序列化看Unity3D的存储机制</title>
    <url>/2019/11/18/%E4%BB%8E%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%8BUnity3D%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>貌似从来没有看过一本关于Unity的书籍就找了本看看。</p>
<p>本书为《Unity3D脚本编程》</p>
</blockquote>
<p>序列化对象的和反序列化的操作</p>
<p>序列化和反序列化与程序集的关系 </p>
]]></content>
      <categories>
        <category>C#</category>
        <category>读书</category>
        <category>Unity</category>
        <category>Unity3D脚本编程</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>序列化</tag>
        <tag>反序列化</tag>
        <tag>存储机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Type</title>
    <url>/2019/11/16/Type/</url>
    <content><![CDATA[<p>Type类，是一个用来存储类型的特性和信息的类。对于程序中的每一个类型，都会有他自己的类信息，而根据Type提供的书信和方法获得这个类型的一切信息，包括字段，属性，事件，参数，构造函数等。</p><h2 id="生成Type对象"><a href="#生成Type对象" class="headerlink" title="生成Type对象"></a>生成Type对象</h2><a id="more"></a>
<p>Type type = typeof(Test);<br>Test test= new Test();<br>Type type2 = Test.GetType();</p>
<h2 id="获取该类型的信息"><a href="#获取该类型的信息" class="headerlink" title="获取该类型的信息"></a>获取该类型的信息</h2><p>//类的名称<br>string name = type.Name;<br>//类的命名空间<br>string space = type.Namespace;<br>//类的程序集<br>Assembly assembly = type.Assembly;<br>//类的共有字段<br>FieldInfo[] fieldInfos = type.GetFields();<br>//类的属性<br>PropertyInfo[] propertyInfos = type.GetProperties();<br>//类的方法<br>MethodInfo[] methodInfos = type.GetMethods();</p>
<h2 id="typeof-和GetType的区别"><a href="#typeof-和GetType的区别" class="headerlink" title="typeof 和GetType的区别"></a>typeof 和GetType的区别</h2><p>C#中任何对象都具有GetType()方法，它的作用和typeof()相同，返回Type类型的当前对象的类型。</p>
<p>typeof(x)中的x，必须是具体的类名、类型名称等(int ,string,自定义类等等)，不可以是变量名称；</p>
<p>GetType()是基类System.Object的方法，因此只有建立一个实例之后才能够被调用</p>
<p>typeof是运算符，GetType是一个实例的方法。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Type</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity封装DeBug.Log代码定位</title>
    <url>/2019/11/16/Unity%E5%B0%81%E8%A3%85DeBug-Log%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UnityConsoleWindow双击定位Debug.Log输出日志。</p><p>但是一般封装Debug.Log日志定位就不是自己想要的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Reflection;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line">using UnityEditor;</span><br><span class="line">public class LogEditor</span><br><span class="line">&#123;  </span><br><span class="line">  private static LogEditor m_Instance;  </span><br><span class="line">  public static LogEditor GetInstacne()</span><br><span class="line">  &#123;</span><br><span class="line">    if (m_Instance == null)</span><br><span class="line">    &#123;</span><br><span class="line">      m_Instance = new LogEditor();</span><br><span class="line">    &#125;    return m_Instance;</span><br><span class="line">  &#125;</span><br><span class="line">  private const string DEBUGERFILEPATH = &quot;Assets/Script/Util/HHLogger.cs&quot;;//替换成你自己的封装类地址</span><br><span class="line">  private int m_DebugerFileInstanceId;</span><br><span class="line">  private Type m_ConsoleWindowType = null;</span><br><span class="line">  private FieldInfo m_ActiveTextInfo;</span><br><span class="line">  private FieldInfo m_ConsoleWindowFileInfo;  </span><br><span class="line">  </span><br><span class="line">  private LogEditor()</span><br><span class="line">  &#123;</span><br><span class="line">    UnityEngine. Object debuggerFile = AssetDatabase.LoadAssetAtPath(DEBUGERFILEPATH,typeof(UnityEngine.Object));</span><br><span class="line">    m_DebugerFileInstanceId = debuggerFile.GetInstanceID();    </span><br><span class="line">    m_ConsoleWindowType = Type.GetType(&quot;UnityEditor.ConsoleWindow,UnityEditor&quot;);</span><br><span class="line">    m_ActiveTextInfo = m_ConsoleWindowType.GetField(&quot;m_ActiveText&quot;, BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">    m_ConsoleWindowFileInfo = m_ConsoleWindowType.GetField(&quot;ms_ConsoleWindow&quot;, BindingFlags.Static | BindingFlags.NonPublic);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  [UnityEditor.Callbacks.OnOpenAssetAttribute(-1)]</span><br><span class="line">  private static bool OnOpenAsset(int instanceID, int line)</span><br><span class="line">  &#123;</span><br><span class="line">    if (instanceID == LogEditor.GetInstacne().m_DebugerFileInstanceId &amp;&amp; line != -1)</span><br><span class="line">    &#123;</span><br><span class="line">      return LogEditor.GetInstacne().FindCode();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public bool FindCode()</span><br><span class="line">  &#123;</span><br><span class="line">    var windowInstance = m_ConsoleWindowFileInfo.GetValue(null);</span><br><span class="line">    var activeText = m_ActiveTextInfo.GetValue(windowInstance);    </span><br><span class="line">    string[] contentStrings = activeText.ToString().Split(&apos;\n&apos;);</span><br><span class="line">    List&lt;string&gt; filePath = new List&lt;string&gt;();</span><br><span class="line">    for (int index = 0; index &lt; contentStrings.Length; index++)</span><br><span class="line">    &#123;</span><br><span class="line">      if (contentStrings[index].Contains(&quot;at&quot;))</span><br><span class="line">      &#123;</span><br><span class="line">        filePath.Add(contentStrings[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    bool success = PingAndOpen(filePath[1]);</span><br><span class="line">    return success;</span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  public bool PingAndOpen(string fileContext)</span><br><span class="line">  &#123;</span><br><span class="line">    string regexRule = @&quot;at ([\w\W]*):(\d+)\)&quot;;    </span><br><span class="line">    Match match = Regex.Match(fileContext, regexRule);</span><br><span class="line">    if (match.Groups.Count &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">      string path = match.Groups[1].Value;</span><br><span class="line">      string line = match.Groups[2].Value;</span><br><span class="line">      UnityEngine.Object codeObject = AssetDatabase.LoadAssetAtPath(path, typeof(UnityEngine.Object));</span><br><span class="line">      if (codeObject == null)</span><br><span class="line">      &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;      </span><br><span class="line">      EditorGUIUtility.PingObject(codeObject);</span><br><span class="line">      AssetDatabase.OpenAsset(codeObject, int.Parse(line));      </span><br><span class="line">      return true;</span><br><span class="line">    &#125;    </span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static class HHLogger</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  // 正式发布改成true</span><br><span class="line">  static bool isTrue = false;</span><br><span class="line">  //static bool isTrue = true;</span><br><span class="line"></span><br><span class="line">  public static void DEBUG(params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    if (isTrue)</span><br><span class="line">      return;</span><br><span class="line">    object msg;</span><br><span class="line">    parseParams(out msg, arrParams);</span><br><span class="line">    Debug.Log(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void WARN(params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    if (isTrue)</span><br><span class="line">      return;</span><br><span class="line">    object msg;</span><br><span class="line">    parseParams(out msg, arrParams);</span><br><span class="line">    Debug.LogWarning(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void ERROR(params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    if (isTrue)</span><br><span class="line">      return;</span><br><span class="line">    object msg;</span><br><span class="line">    parseParams(out msg, arrParams);</span><br><span class="line">    Debug.LogError(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void parseParams(out object msg, params object[] arrParams)</span><br><span class="line">  &#123;</span><br><span class="line">    msg = string.Empty;</span><br><span class="line">    for (int i = 0; i &lt; arrParams.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      msg += &quot;[&quot; + arrParams[i] + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.cppblog.com/heath/archive/2016/06/21/213777.html" target="_blank" rel="noopener">解决在Unity中封装Debug.Log后代码行定位问题</a></p>
<p><a href="https://blog.csdn.net/sinat_34870723/article/details/84979106" target="_blank" rel="noopener">https://blog.csdn.net/sinat_34870723/article/details/84979106</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>代码块</tag>
        <tag>打印</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-打印帧率</title>
    <url>/2019/11/14/Unity-%E6%89%93%E5%8D%B0%E5%B8%A7%E7%8E%87/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ShowFPS : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public int fpsTarget;</span><br><span class="line"></span><br><span class="line">    public float updateInterval = 0.5f;</span><br><span class="line">    private float lastInterval;</span><br><span class="line">    private int frames = 0;</span><br><span class="line">    private float fps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        //设置帧率</span><br><span class="line">        Application.targetFrameRate = 60;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lastInterval = Time.realtimeSinceStartup;</span><br><span class="line">        frames = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Update is called once per frame  </span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        ++frames;</span><br><span class="line">        float timeNow = Time.realtimeSinceStartup;</span><br><span class="line">        if (timeNow &gt;= lastInterval + updateInterval)</span><br><span class="line">        &#123;</span><br><span class="line">            fps = frames / (timeNow - lastInterval);</span><br><span class="line">            frames = 0;</span><br><span class="line">            lastInterval = timeNow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        GUI.Label(new Rect(200, 40, 100, 30), fps.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>代码块</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity插件-TouchConsole</title>
    <url>/2019/11/14/Unity%E6%8F%92%E4%BB%B6-TouchConsole/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>打印</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客文章插入图片</title>
    <url>/2019/11/09/Hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>在写文章时，常常有配图说明的需求。Hexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。</p><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>当Hexo项目中只用到少量图片时，可以将图片统一放在<code>source/images</code>文件夹中，通过markdown语法访问它们。</p><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source/images/image.jpg![](/images/image.jpg)</span><br></pre></td></tr></table></figure>

<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>
<h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>图片除了可以放在统一的<code>images</code>文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置<code>_config.yml</code>来生成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.ymlpost_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>将<code>_config.yml</code>文件中的配置项<code>post_asset_folder</code>设为<code>true</code>后，执行命令<code>$ hexo new post_name</code>，在<code>source/_posts</code>中会生成文章<code>post_name.md</code>和同名文件夹<code>post_name</code>。将图片资源放在<code>post_name</code>中，文章就可以使用相对路径引用图片资源了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_posts/Hexo博客文章插入图片/1.png![](1.png)</span><br></pre></td></tr></table></figure>

<p><img src="1.png" alt></p>
<p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p>
<p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_posts/post_name/image.jpg&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h4><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如<a href="http://cloudinary.com/" target="_blank" rel="noopener">Cloudinary</a>提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在Unity中使用AssetBundle</title>
    <url>/2019/11/09/%E5%9C%A8Unity%E4%B8%AD%E4%BD%BF%E7%94%A8AssetBundle/</url>
    <content><![CDATA[<h1 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>Unity引擎识别的资源格式，自定义的二进制文件后缀必须是“bytes”</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Unity自己有一个</p><p>博主<a href="https://blog.csdn.net/qq992817263/article/list/2?t=1&amp;" target="_blank" rel="noopener">https://blog.csdn.net/qq992817263/article/list/2?t=1&amp;</a></p><a id="more"></a>


<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> <a href="https://blog.csdn.net/lodypig/article/details/51863683#comments" target="_blank" rel="noopener">https://blog.csdn.net/lodypig/article/details/51863683#comments</a></p>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>笔记</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言</title>
    <url>/2019/11/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>提到汇编语言不得不提机器语言</p><ul>
<li>机器语言</li>
</ul><p>机器语言：机器指令的集合（二进制数字0，1）<br>计算机转变为一列高低电平，以使计算机的电子器受到驱动，进行运算。</p><ul>
<li>汇编语言 </li>
</ul><p>实质与机器语言相同，直接对硬件操作。将源程序汇编生成的<strong>可执行文件</strong><br>组成：指令、伪指令和宏指令</p><a id="more"></a>




<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>高级语言是依赖编译或者解析的<br>如：C、C++、Python、Java、Matlab、LabVIEW等等</p>
<ul>
<li>低级语言：泛指机器语言和汇编语言</li>
</ul>
<h3 id="按转换方式划分"><a href="#按转换方式划分" class="headerlink" title="按转换方式划分"></a>按转换方式划分</h3><ul>
<li>解释型：一边“翻译”成目标代码（机器语言）一边执行</li>
<li>编译型：应用源程序执行之前，就将程序源代码“翻译”成目标代码（机器语言）</li>
</ul>
<p>解释型语言中包括脚本语言（又叫动态语言，扩建的语言）</p>
<ul>
<li>脚本语言：shell，Lua，php</li>
</ul>
<p>脚本语言作为一钟解释型语言，一般以文本的形式存在，<strong>脚本语言可分为独立型和嵌入型</strong>，独立型脚本语言在其执行时完全依赖于解释器，而嵌入型脚本语言通常在编程语言中（如C，C++，VB，Java等）被嵌入使用。</p>
<h3 id="其他分类方式"><a href="#其他分类方式" class="headerlink" title="其他分类方式"></a>其他分类方式</h3><ul>
<li>动态语言：语言的数据类型判断是在运行中判断</li>
<li>静态语言：语言的数据类型判断是在运行前判断（如编译阶段）如：C、C++，C#，java</li>
</ul>
<ul>
<li>强类型语言：变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换 如：Java</li>
<li>弱类型语言：它与强类型语言定义相反,允许编译器进行隐式的类型转换如：C、C++<h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2></li>
<li>动态语言和静态语言</li>
<li>强类型语言和弱类型语言</li>
<li>解释型语言和编译型语言</li>
<li>机器语言和汇编语言<h2 id="分析案例"><a href="#分析案例" class="headerlink" title="分析案例"></a>分析案例</h2></li>
<li>C#</li>
<li>C</li>
<li>C++</li>
<li>Java</li>
<li>Lua</li>
<li>Pyhon<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2></li>
<li>CLR和.Net</li>
</ul>
<p>.Net是一种解决方案; C# 是.Net解决方案中的一种语言; CLR是.Net的运行架构.</p>
<ol>
<li>CLR是公共语言运行库(Common Language Runtime)和Java虚拟机<br>一样也是一个运行时环境，它负责资源管理(内存分配和垃圾收集等),并保<br>证应用和底层操作系统之间必要的分离。</li>
<li>NET FrameWork的核心是其运行库执行环境，称为公共语言运行库(Common Language Runtime)。</li>
<li>作用：<br>（1）CLR是一个类似于JVM的虚拟机，为微软的.Net产品提供运行环境。<br>（2）CLR上实际运行的并不是我们通常所用的编程语言(例如C#、VB等)，而是一种字节码形态的“中间语言”。<br>这意味着只要能将代码编译成这种特定的“中间语言”(MSIL),任何语言的产品都能运行在CLR上。<br>（3）CLR通常被运行在Windows系统上，但是也有一些非Windows的版本。这意味着.Net也很容易实现<br>“跨平台”。(至于为什么大家的印象中.Net的跨平台性不如Java，更多的是微软商业战略导致的)。<br>语言支持：<br>微软已经为多种语言开发了基于CLR的编译器，这些语言包括：C++/CLI、C#、Visual Basic、F#、<br>Iron Python、 Iron Ruby和IL。除此之外，其他的一些公司和大学等机构也位一些语言开发了基于CLR<br>的编译器，例如Ada、APL、Caml、COBOL、Eiffel、Forth、Fortran、Haskell、Lexicon、LISP、<br>LOGO、Lua、Mercury、ML、Mondrian、Oberon、Pascal、Perl、PHP、Prolog、RPG、Scheme、<br>Smaltak、Tcl/Tk。</li>
</ol>
<p>CLR为不同的编程语言提供了统一的运行平台，在很大程度上对上层开发者屏蔽了语言之间才特性差异。<br>对于CLR来说，不同语言的编译器(Compiler)就相当于一个这种语言的代码审查者(Checker),所做的<br>工作就是检查源码语法是否正确，然后将源码编译成CLR所需要的中间语言(IL)。所以编程语言对于CLR<br>是透明的，也就是说CLR只知道IL的存在，而不知道IL是由哪种语言编译而来。<br>功能：<br>（1）基类库支持 (Base Class Library Support)<br>（2）内存管理 (Memory Management)<br>（3）线程管理 (Thread Management)<br>（4）垃圾回收 (Garbage Collection)<br>（5）安全性 (Security)<br>（6）类型检查 (Type Checker)<br>（7）异常处理 (Exception Manager)<br>（8）即时编译 (JIT)<br><img src="https://img-blog.csdnimg.cn/20190729183322381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190729190632358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>具体过程：<br>CIL（IL）： CIL类似一个面向对象的汇编语言，并且它是完全基于堆栈的，它运行在虚拟机上（.Net Framework, Mono VM）的语言<br>遵循LI规范的高级语言，被先被各自的编译器编译成中间语言：IL（CIL），等到需要真正执行的时候，这些IL会被加载到运行时库，也就是VM中，由<strong>VM</strong>动态的编译成汇编代码（JIT）然后在执行。<br>IL2CPP <a href="https://www.cnblogs.com/lancidie/p/6258154.html" target="_blank" rel="noopener">https://www.cnblogs.com/lancidie/p/6258154.html</a> ：Mono vm –&gt;IL2CPP vm</p>
<ul>
<li>AOT和JIT</li>
</ul>
<p><a href="https://blog.csdn.net/h1130189083/article/details/78302502" target="_blank" rel="noopener">https://blog.csdn.net/h1130189083/article/details/78302502</a></p>
<ul>
<li>程序集的组成</li>
</ul>
<p>1.程序集清单，包含描述该程序集中各元素彼此如何关联的数据集合，还包含指定该程序集的版本要求和安全标识所需的所有元数据，以及定义该程序集的范围和解析对资源和类的应用所需的全部元数据。<br>2.元数据，提供有关程序集中定义的类型的信息，包括类型的名称，可见性，基类和类型所实现的接口。注意：程序集清单和元数据说明了程序集是自我描述的。<br>3.实现这些类型的MSIL代码。<br>4.资源集，诸如位图，指针，静态文本等。</p>
<ul>
<li>程序集和命名空间的关系</li>
</ul>
<p>命名空间用于对类型进行逻辑分组。<strong>程序集则是程序的物理分组，对应于一个dll或exe文件。</strong><br>程序集1：<br>namespace1{<br>    public class A1{…}<br>    public class A2{…}<br>}</p>
<p>namespace2{<br>    public class A3{…}<br>    public class A4{…}<br>}</p>
<p>程序集2：<br>namespace1{<br>    public class B1{…}<br>    public class B2{…}<br>}</p>
<p>namesapce2{<br>    public class B3{…}<br>    public class B4{…}<br>}<br><a href="https://blog.csdn.net/DY_1024/article/details/82946643" target="_blank" rel="noopener">https://blog.csdn.net/DY_1024/article/details/82946643</a> </p>
<ul>
<li>托管模块</li>
</ul>
<p>中间语言代码（Microsoft Intermediate Language MSIL==IL)就是托管代码）<br><img src="https://img-blog.csdnimg.cn/2019072919413937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190729194154717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>编程语言</tag>
        <tag>CLR</tag>
        <tag>.Net</tag>
        <tag>程序集</tag>
        <tag>托管模块</tag>
        <tag>托管语言</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityMono脚本</title>
    <url>/2019/11/06/UnityMono%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h1><p><img src="../images/mono_1.jpg" alt="mono_1"></p>
<p>TODO 现在的垃圾回收机制</p>
<p>TODO 现在IL2Cpp喝MONO的区别 到底改变的是什么</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Mono</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityWWW类的用法</title>
    <url>/2019/11/05/UnityWWW%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h1><p>支持get和post两种方式 -TODO get poss http传送区别</p><p><a href="https://www.cnblogs.com/Jason-c/p/10559141.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jason-c/p/10559141.html</a></p><p><a href="https://blog.csdn.net/yzy565280261/article/details/80146097" target="_blank" rel="noopener">https://blog.csdn.net/yzy565280261/article/details/80146097</a></p><a id="more"></a>


<p>TODO TCP HTTP UDP</p>
<p>TODO <a href="https://www.jianshu.com/p/cd185f40c53a" target="_blank" rel="noopener">https://www.jianshu.com/p/cd185f40c53a</a></p>
<p><a href="https://www.cnblogs.com/hanfanfan/p/9579771.html" target="_blank" rel="noopener">https://www.cnblogs.com/hanfanfan/p/9579771.html</a></p>
<p>扩展封装</p>
<p><a href="https://blog.csdn.net/lizhenxiqnmlgb/article/details/82864230" target="_blank" rel="noopener">https://blog.csdn.net/lizhenxiqnmlgb/article/details/82864230</a></p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>C#this,base</title>
    <url>/2019/10/31/C-this/</url>
    <content><![CDATA[<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><h5 id="原始类型扩展方法"><a href="#原始类型扩展方法" class="headerlink" title="原始类型扩展方法"></a>原始类型扩展方法</h5><pre><code>* 静态方法
* 第一个参数作用类型
* using引用命名空间</code></pre><blockquote>
<p>​    static public GameObject AddChildNew(this GameObject parent) { return AddChild(parent, true); } </p>
</blockquote><a id="more"></a>
<h5 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h5><p>#####显式调用一个类的方法和成员  略</p>
<h5 id="串联构造函数-lt-gt-对比Base"><a href="#串联构造函数-lt-gt-对比Base" class="headerlink" title="串联构造函数 &lt;=&gt; 对比Base"></a>串联构造函数 &lt;=&gt; 对比Base</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">  &#123;</span><br><span class="line">    public Test()</span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(&quot;无参构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里的this()指向的是Test()无参构造函数</span><br><span class="line">    // 相当于继承了无参构造函数</span><br><span class="line">    public Test(string text) : this()</span><br><span class="line">    &#123;</span><br><span class="line">      // 程序进来后会先执行Test()无参函数，然后继续往下边执行</span><br><span class="line">      Console.WriteLine(text);</span><br><span class="line">      Console.WriteLine(&quot;有参构造函数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/foolin/archive/2011/10/11/UsageThis.html" target="_blank" rel="noopener">轮子</a></p>
<p>####Base</p>
<h5 id="在派生类中调用基类的方法"><a href="#在派生类中调用基类的方法" class="headerlink" title="在派生类中调用基类的方法"></a>在派生类中调用基类的方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">        public virtual void Hello()</span><br><span class="line">        &#123;</span><br><span class="line">                Console.WiriteLine(&quot;Hello&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B : A</span><br><span class="line">&#123;</span><br><span class="line">        public override void Hello()</span><br><span class="line">        &#123;               </span><br><span class="line">                base.Hello();//调用基类的方法,显示Hello</span><br><span class="line">                Console.WiriteLine(&quot;World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用基类构造函数"><a href="#调用基类构造函数" class="headerlink" title="调用基类构造函数"></a>调用基类构造函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">        public A()</span><br><span class="line">        &#123;</span><br><span class="line">                Console.WriteLine(&quot;Build A&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B:A</span><br><span class="line">&#123;</span><br><span class="line">        public B():base()</span><br><span class="line">        &#123;</span><br><span class="line">                Console.WriteLine(&quot;Build B&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">                B b = new B();</span><br><span class="line">                Console.ReadLine();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="区别-构造"><a href="#区别-构造" class="headerlink" title="区别 - 构造"></a>区别 - 构造</h4><p>修饰构造时，所代表的构造方法：一个时来自 父类base，一个是来自于当前类this。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>this</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>异步、并发、协程原理</title>
    <url>/2019/10/31/%E5%BC%82%E6%AD%A5%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、异步"><a href="#一、异步" class="headerlink" title="一、异步"></a>一、异步</h2><h2 id="应用程序和内核"><a href="#应用程序和内核" class="headerlink" title="应用程序和内核"></a>应用程序和内核</h2><p>内核具有最高权限，可以访问受保护的内存空间，可以访问底层的硬件设备。而这些是应用程序所不具备的，但应用程序可以通过调用内核提供的接口来间接访问或操作。所谓的常见的 IO 模型就是基于应用程序和内核之间的交互所提出来的。以一次网络 IO 请求过程中的 read 操作为例，请求数据会先拷贝到系统内核的缓冲区（内核空间），再从操作系统的内核缓冲区拷贝到应用程序的地址空间（用户空间）。而从内核空间将数据拷贝到用户空间过程中，就会经历两个阶段：</p><a id="more"></a>
<ul>
<li>等待数据准备</li>
<li>拷贝数据</li>
</ul>
<p>也正因为有了这两个阶段，才提出了各种网络 I/O 模型。</p>
<h3 id="Unix-Linux的体系架构"><a href="#Unix-Linux的体系架构" class="headerlink" title="Unix/Linux的体系架构"></a>Unix/Linux的体系架构</h3><p><img src="http://www.iigrowing.cn/wp-content/uploads/2018/09/52599826b6c16e428b2f6999907e4703.png" alt="img"></p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步（Synchronised）和异步（Asynchronized）的概念描述的是应用程序与内核的交互方式，同步是指应用程序发起 I/O 请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行；而异步是指应用程序发起 I/O 请求后仍继续执行，当内核 I/O 操作完成后会通知应用程序，或者调用应用程序注册的回调函数。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞的概念描述的是应用程序调用内核 IO 操作的方式，阻塞是指 I/O 操作需要彻底完成后才返回到用户空间；而非阻塞是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。</p>
<p><strong>常见的网络I/O模型大概有四种：</strong></p>
<ol>
<li>同步阻塞IO（Blocking IO）</li>
<li>同步非阻塞IO（Non-blocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>异步IO（Asynchronous IO）</li>
</ol>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）。 <strong>IO 多路复用是异步阻塞的。</strong></p>
<h2 id="二、并发"><a href="#二、并发" class="headerlink" title="二、并发"></a>二、并发</h2><p>并发，在操作系统中，是指 <strong>一个时间段</strong> 中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
<p><strong>并发和并行的区别：</strong></p>
<ul>
<li>并发（concurrency）：逻辑上具备同时处理多个任务的能力。</li>
<li>并行（parallesim）：物理上在同一时刻执行多个并发任务，依赖多核处理器等物理设备。</li>
</ul>
<p>多线程或多进程是并行的基本条件，但单线程也可用协程做到并发。通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源；用协程来提高处理器时间片利用率。现代系统中，多核 CPU 可以同时运行多个不同的进程或者线程。所以并发程序可以是并行的，也可以不是。</p>
<h2 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h2><p>在了解协程前先了解一些概念：</p>
<h3 id="1、线程模型"><a href="#1、线程模型" class="headerlink" title="1、线程模型"></a>1、线程模型</h3><p>在现代计算机结构中，先后提出过两种线程模型：用户级线程（user-level threads）和内核级线程（kernel-level threads）。所谓用户级线程是指，应用程序在操作系统提供的单个控制流的基础上，通过在某些控制点（比如系统调用）上分离出一些虚拟的控制流，从而模拟多个控制流的行为。由于应用程序对指令流的控制能力相对较弱，所以，用户级线程之间的切换往往受线程本身行为以及线程控制点选择的影响，线程是否能公平地获得处理器时间取决于这些线程的代码特征。而且，支持用户级线程的应用程序代码很难做到跨平台移植，以及对于多线程模型的透明。用户级线程模型的优势是线程切换效率高，因为它不涉及系统内核模式和用户模式之间的切换；另一个好处是应用程序可以采用适合自己特点的线程选择算法，可以根据应用程序的逻辑来定义线程的优先级，当线程数量很大时，这一优势尤为明显。但是，这同样会增加应用程序代码的复杂性。有一些软件包（如 POSIXThreads 或 Pthreads 库）可以减轻程序员的负担。</p>
<p>内核级线程往往指操作系统提供的线程语义，由于操作系统对指令流有完全的控制能力，甚至可以通过硬件中断来强迫一个进程或线程暂停执行，以便把处理器时间移交给其他的进程或线程，所以，内核级线程有可能应用各种算法来分配处理器时间。线程可以有优先级，高优先级的线程被优先执行，它们可以抢占正在执行的低优先级线程。在支持线程语义的操作系统中，处理器的时间通常是按线程而非进程来分配，因此，系统有必要维护一个全局的线程表，在线程表中记录每个线程的寄存器、状态以及其他一些信息。然后，系统在适当的时候挂起一个正在执行的线程，选择一个新的线程在当前处理器上继续执行。这里“适当的时候”可以有多种可能，比如：当一个线程执行某些系统调用时，例如像 sleep 这样的放弃执行权的系统函数，或者像 wait 或 select 这样的阻塞函数；硬中断（interrupt）或异常（exception）；线程终止时，等等。由于这些时间点的执行代码可能分布在操作系统的不同位置，所以，在现代操作系统中，线程调度（thread scheduling）往往比较复杂，其代码通常分布在内核模块的各处。</p>
<p>内核级线程的好处是，应用程序无须考虑是否要在适当的时候把控制权交给其他的线程，不必担心自己霸占处理器而导致其他线程得不到处理器时间。应用线程只要按照正常的指令流来实现自己的逻辑即可，内核会妥善地处理好线程之间共享处理器的资源分配问题。然而，这种对应用程序的便利也是有代价的，即，所有的线程切换都是在内核模式下完成的，因此，对于在用户模式下运行的线程来说，一个线程被切换出去，以及下次轮到它的时候再被切换进来，要涉及两次模式切换：从用户模式切换到内核模式，再从内核模式切换回用户模式。在 Intel 的处理器上，这种模式切换大致需要几百个甚至上千个处理器指令周期。但是，随着处理器的硬件速度不断加快，模式切换的开销相对于现代操作系统的线程调度周期（通常几十毫秒）的比例正在减小，所以，这部分开销是完全可以接受的。</p>
<p>除了线程切换的开销是一个考虑因素以外，线程的创建和删除也是一个重要的考虑指标。当线程的数量较多时，这部分开销是相当可观的。虽然线程的创建和删除比起进程要轻量得多，但是，在一个进程内建立起一个线程的执行环境，例如，分配线程本身的数据结构和它的调用栈，完成这些数据结构的初始化工作，以及完成与系统环境相关的一些初始化工作，这些负担是不可避免的。另外，当线程数量较多时，伴随而来的线程切换开销也必然随之增加。所以，当应用程序或系统进程需要的线程数量可能比较多时，通常可采用线程池技术作为一种优化措施，以降低创建和删除线程以及线程频繁切换而带来的开销。</p>
<p>在支持内核级线程的系统环境中，进程可以容纳多个线程，这导致了多线程程序设计（multithreaded programming）模型。由于多个线程在同一个进程环境中，它们共享了几乎所有的资源，所以，线程之间的通信要方便和高效得多，这往往是进程间通信（IPC，Inter-Process Communication）所无法比拟的，但是，这种便利性也很容易使线程之间因同步不正确而导致数据被破坏，而且，这种错误存在不确定性，因而相对来说难以发现和调试。</p>
<h3 id="2、什么是协同式和抢占式？"><a href="#2、什么是协同式和抢占式？" class="headerlink" title="2、什么是协同式和抢占式？"></a>2、什么是协同式和抢占式？</h3><p>许多协同式多任务操作系统，也可以看成协程运行系统。说到协同式多任务系统，一个常见的误区是认为协同式调度比抢占式调度“低级”，因为我们所熟悉的桌面操作系统，都是从协同式调度（如 Windows 3.2， Mac OS 9 等）过渡到抢占式多任务系统的。实际上，调度方式并无高下，完全取决于应用场景。抢占式系统允许操作系统剥夺进程执行权限，抢占控制流，因而天然适合服务器和图形操作系统，因为调度器可以优先保证对用户交互和网络事件的快速响应。当年 Windows 95 刚刚推出的时候，抢占式多任务就被作为一大买点大加宣传。协同式调度则等到进程时间片用完或系统调用时转移执行权限，因此适合实时或分时等等对运行时间有保障的系统。</p>
<p>另外，抢占式系统依赖于 CPU 的硬件支持。 因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有 CPU 支持了执行权限后，抢占式调度才成为可能。x86 系统从 80386 处理器开始引入 Ring 机制支持执行权限，这也是为何 Windows 95 和 Linux 其实只能运行在 80386 之后的 x86 处理器上的原因。而协同式多任务适用于那些没有处理器权限支持的场景，这些场景包含资源受限的嵌入式系统和实时系统。在这些系统中，程序均以协程的方式运行。调度器负责控制流的让出和恢复。通过协程的模型，无需硬件支持，我们就可以在一个“简陋”的处理器上实现一个多任务的系统。我们见到的许多智能设备，如运动手环，基于硬件限制，都是采用协同调度的架构。</p>
<h3 id="协程基本概念"><a href="#协程基本概念" class="headerlink" title="协程基本概念"></a>协程基本概念</h3><p>“协程”（Coroutine）概念最早由 Melvin Conway 于 1958 年提出。协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。总的来说，协程为协同任务提供了一种运行时抽象，这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。</p>
<p>从编程角度上看，协程的思想本质上就是控制流的主动让出（yield）和恢复（resume）机制，迭代器常被用来实现协程，所以大部分的语言实现的协程中都有 yield 关键字，比如 Python、PHP、Lua。但也有特殊比如 Go 就使用的是通道来通信。</p>
<p>有趣的是协程的历史其实要早于线程。</p>
<p>WIKI 的解释：</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as <strong>cooperative tasks, exceptions, event loop, iterators, infinite lists and pipes.</strong></p>
</blockquote>
<h3 id="进程、线程、协程的特点及区别"><a href="#进程、线程、协程的特点及区别" class="headerlink" title="进程、线程、协程的特点及区别"></a>进程、线程、协程的特点及区别</h3><p><a href="https://blog.csdn.net/chengqiuming/article/details/80573288" target="_blank" rel="noopener">对比图</a></p>
<h4 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h4><ul>
<li>进程是资源分配的最小单位</li>
<li>进程间不共享内存，每个进程拥有自己独立的内存</li>
<li>进程间可以通过信号、信号量、共享内存、管道、队列等来通信</li>
<li>新开进程开销大，并且 CPU 切换进程成本也大</li>
<li>进程由操作系统调度</li>
<li>多进程方式比多线程更加稳定</li>
</ul>
<h4 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h4><ul>
<li>线程是程序执行流的最小单位</li>
<li>线程是来自于进程的，一个进程下面可以开多个线程</li>
<li>每个线程都有自己一个栈，不共享栈，但多个线程能共享同一个属于进程的堆</li>
<li>线程因为是在同一个进程内的，可以共享内存</li>
<li>线程也是由操作系统调度，线程是 CPU 调度的最小单位</li>
<li>新开线程开销小于进程，CPU 在切换线程成本也小于进程</li>
<li>某个线程发生致命错误会导致整个进程崩溃</li>
<li>线程间读写变量存在锁的问题处理起来相对麻烦</li>
</ul>
<h4 id="协程（coroutine）"><a href="#协程（coroutine）" class="headerlink" title="协程（coroutine）"></a>协程（coroutine）</h4><ul>
<li>对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的</li>
<li>协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权</li>
<li>切换非常快，成本低。一般占用栈大小远小于线程（协程 KB 级别，线程 MB 级别），所以可以开更多的协程</li>
<li>协程比线程更轻量级</li>
</ul>
<p><strong>不同模型下用户空间与内核空间的关系：</strong></p>
<p><img src="http://www.iigrowing.cn/wp-content/uploads/2018/09/0f8aeb27d963b1c8ed371a1a3c9d4d07.png" alt="img"></p>
<p>注：协程可以理解为上图中的用户级线程模型。</p>
<h4 id="支持协程的语言"><a href="#支持协程的语言" class="headerlink" title="支持协程的语言"></a>支持协程的语言</h4><ul>
<li>Simula</li>
<li>Modula-2</li>
<li>C#</li>
<li>Lua</li>
<li>Go</li>
<li>JavaScript(ECMA-262 6th Edition)</li>
<li>Python</li>
<li>Ruby</li>
<li>Erlang</li>
<li>PHP（PHP5.5+）</li>
<li>…</li>
</ul>
<p><a href="http://www.iigrowing.cn/?p=6736" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>异步</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>编码：ASCII，Unicode和UTF-8</title>
    <url>/2019/10/30/%E7%BC%96%E7%A0%81%EF%BC%9AASCII%EF%BC%8CUnicode%E5%92%8CUTF-8/</url>
    <content><![CDATA[<h2 id="一、ASCII-码"><a href="#一、ASCII-码" class="headerlink" title="一、ASCII 码"></a><strong>一、ASCII 码</strong></h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有<code>0</code>和<code>1</code>两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从<code>00000000</code>到<code>11111111</code>。</p><a id="more"></a>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>
<p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p>
<h2 id="二、非-ASCII-编码"><a href="#二、非-ASCII-编码" class="headerlink" title="二、非 ASCII 编码"></a><strong>二、非 ASCII 编码</strong></h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的<code>é</code>的编码为130（二进制<code>10000010</code>）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p>
<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>
<p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>
<p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p>
<h2 id="三-Unicode"><a href="#三-Unicode" class="headerlink" title="三. Unicode"></a><strong>三. Unicode</strong></h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/" target="_blank" rel="noopener">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字对应表</a>。</p>
<h2 id="四、Unicode-的问题"><a href="#四、Unicode-的问题" class="headerlink" title="四、Unicode 的问题"></a><strong>四、Unicode 的问题</strong></h2><p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<p>比如，汉字<code>严</code>的 Unicode 是十六进制数<code>4E25</code>，转换成二进制数足足有15位（<code>100111000100101</code>），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p>
<h2 id="五、UTF-8"><a href="#五、UTF-8" class="headerlink" title="五、UTF-8"></a><strong>五、UTF-8</strong></h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</strong></p>
<p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">&gt; (十六进制)        |              （二进制）</span><br><span class="line">&gt; ----------------------+---------------------------------------------</span><br><span class="line">&gt; 0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">&gt; 0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">&gt; 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">&gt; 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p>
<p><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p>
<h2 id="六、Unicode-与-UTF-8-之间的转换"><a href="#六、Unicode-与-UTF-8-之间的转换" class="headerlink" title="六、Unicode 与 UTF-8 之间的转换"></a><strong>六、Unicode 与 UTF-8 之间的转换</strong></h2><p>通过上一节的例子，可以看到<code>严</code>的 Unicode码 是<code>4E25</code>，UTF-8 编码是<code>E4B8A5</code>，两者是不一样的。它们之间的转换可以通过程序实现。</p>
<p>Windows平台，有一个最简单的转化方法，就是使用内置的记事本小程序<code>notepad.exe</code>。打开文件后，点击<code>文件</code>菜单中的<code>另存为</code>命令，会跳出一个对话框，在最底部有一个<code>编码</code>的下拉条。</p>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/bg2007102801.jpg" target="_blank" rel="noopener"><img src="http://www.ruanyifeng.com/blog/2007/10/bg2007102801-thumb.jpg" alt="bg2007102801.jpg"></a></p>
<p>里面有四个选项：<code>ANSI</code>，<code>Unicode</code>，<code>Unicode big endian</code>和<code>UTF-8</code>。</p>
<p>1）<code>ANSI</code>是默认的编码方式。对于英文文件是<code>ASCII</code>编码，对于简体中文文件是<code>GB2312</code>编码（只针对 Windows 简体中文版，如果是繁体中文版会采用 Big5 码）。</p>
<p>2）<code>Unicode</code>编码这里指的是<code>notepad.exe</code>使用的 UCS-2 编码方式，即直接用两个字节存入字符的 Unicode 码，这个选项用的 little endian 格式。</p>
<p>3）<code>Unicode big endian</code>编码与上一个选项相对应。我在下一节会解释 little endian 和 big endian 的涵义。</p>
<p>4）<code>UTF-8</code>编码，也就是上一节谈到的编码方法。</p>
<p>选择完”编码方式”后，点击”保存”按钮，文件的编码方式就立刻转换好了。</p>
<h2 id="七、Little-endian-和-Big-endian"><a href="#七、Little-endian-和-Big-endian" class="headerlink" title="七、Little endian 和 Big endian"></a><strong>七、Little endian 和 Big endian</strong></h2><p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过<code>0xFFFF</code>）。以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p>
<p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p>
<h2 id="八、实例"><a href="#八、实例" class="headerlink" title="八、实例"></a><strong>八、实例</strong></h2><p>下面，举一个实例。</p>
<p>打开”记事本”程序<code>notepad.exe</code>，新建一个文本文件，内容就是一个<code>严</code>字，依次采用<code>ANSI</code>，<code>Unicode</code>，<code>Unicode big endian</code>和<code>UTF-8</code>编码方式保存。</p>
<p>然后，用文本编辑软件<a href="http://www.google.cn/search?aq=t&oq=UltraEdit&complete=1&hl=zh-CN&newwindow=1&rlz=1B3GGGL_zh-CNCN216CN216&q=ultraedit+下载&btnG=Google+搜索&meta=" target="_blank" rel="noopener">UltraEdit 中</a>的”十六进制功能”，观察该文件的内部编码方式。</p>
<p>1）ANSI：文件的编码就是两个字节<code>D1 CF</code>，这正是<code>严</code>的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的。</p>
<p>2）Unicode：编码是四个字节<code>FF FE 25 4E</code>，其中<code>FF FE</code>表明是小头方式存储，真正的编码是<code>4E25</code>。</p>
<p>3）Unicode big endian：编码是四个字节<code>FE FF 4E 25</code>，其中<code>FE FF</code>表明是大头方式存储。</p>
<p>4）UTF-8：编码是六个字节<code>EF BB BF E4 B8 A5</code>，前三个字节<code>EF BB BF</code>表示这是UTF-8编码，后三个<code>E4B8A5</code>就是<code>严</code>的具体编码，它的存储顺序与编码顺序是一致的。</p>
<p>Uncode.org == <a href="https://home.unicode.org/" target="_blank" rel="noopener">https://home.unicode.org/</a></p>
<p>链接</p>
<p> <a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">https://blog.csdn.net/Deft_MKJing/article/details/79460485</a></p>
<p> <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>ascll</tag>
        <tag>unicode</tag>
        <tag>utf-8</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity渲染层级</title>
    <url>/2019/10/29/Unity%E6%B8%B2%E6%9F%93%E5%B1%82%E7%BA%A7/</url>
    <content><![CDATA[<ul>
<li>Camera Depth</li>
<li>Sorting Layer</li>
<li>Order in Layer（粒子）|Sorting Layer</li>
<li>UI自然层级 | 2d或者3d 中z值</li>
</ul><p>其实还有一个Camera Clear Flags。</p><a id="more"></a>

<p>SortingLayer差值2000.</p>
<h5 id="渲染优先级"><a href="#渲染优先级" class="headerlink" title="渲染优先级"></a>渲染优先级</h5><p>渲染优先级有不同层次的控制 </p>
<p>1.不同摄像机之间，通过Depth 来控制渲染顺序，这个优先级最高。 </p>
<p>2.相同Depth情况下，通过修改SotingLayer来确定渲染顺序 </p>
<p>3.相同SotingLayer下，通过sortingOrder（特效中叫做 Order in layer） 来控制。 </p>
<p>Camera.Depth-&gt; Canvas.SotingLayer-&gt;Canvas.OrderInLayer </p>
<p>#####UGUI 的Canvas 的render mode （渲染模式）的选择 </p>
<p>1.Screen Space - Overlay  覆盖模式 </p>
<p>此模式  不需要摄像机。Canvas自适应屏幕大小，不经过投影空间，直接在屏幕上绘制 </p>
<p>这种适合做纯2D游戏。  缺点是对特效不友好，因为界面永远显示在屏幕最前方 </p>
<p>会在任何情况下都会遮挡住特效。 </p>
<p>2.ScreenSpace - Camera  屏幕坐标，相机模式 </p>
<p>Canvas自适应屏幕大小，UI由相机负责渲染，这种非2D游戏都运用。 </p>
<p>由于是相机负责渲染，所以，特效可以被显示出来。可以用UI相机显示， </p>
<p>也可以又专门的特效相机或者主相机渲染。不同相机之间，通过Depth来 </p>
<p>控制渲染优先级，相同相机或者Depth之间，通过SortingOrder来控制 </p>
<p>渲染优先级。 </p>
<p>3.WorldSpace  世界坐标，相机模式 </p>
<p>Canvas不会自适应屏幕大小，UI相当于是平面物体，UI的大小和位置是 </p>
<p>通过UI和相机之间的距离 和位置来决定的。 适合制作角色头顶的血条等 </p>
<h5 id="Unity-Camera-相机-多个相机同时协作"><a href="#Unity-Camera-相机-多个相机同时协作" class="headerlink" title="Unity Camera 相机 多个相机同时协作"></a>Unity Camera 相机 多个相机同时协作</h5><p>每个相机都会渲染自己所渲染的层，对不渲染的层进行剔除。并具有<strong>颜色缓冲和Z缓冲</strong>。通过对每个相机不同的设置，可以达到意想不到的效果。如分屏效果，重点突出等。 </p>
<p>Cuiling Mask：渲染层 </p>
<p>clear flag ： 缓冲区 </p>
<ul>
<li><p>返回天空盒缓冲区并清除</p>
</li>
<li><p>固定颜色</p>
</li>
<li><p>只清楚深度缓冲区</p>
</li>
<li><p>不清除</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Camera</tag>
        <tag>渲染层级</tag>
      </tags>
  </entry>
  <entry>
    <title>Coroutine</title>
    <url>/2019/10/25/Coroutine/</url>
    <content><![CDATA[<h1 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h1><p>##定义</p><p><strong>Process -&gt; Thread -&gt; Coroutine</strong></p><p><strong>协程(Coroutine)编译器级的，进程(Process)和线程(Thread)操作系统级的</strong></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>非线程切换的执行效率，切换由程序本身控制</p>
</li>
<li><p>不需要多线程的锁机制</p>
</li>
</ul><a id="more"></a>



<p><a href="https://www.jianshu.com/p/2782f8c49b2a" target="_blank" rel="noopener">参考文档</a></p>
<p>详见-本博客异步</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="C-迭代器"><a href="#C-迭代器" class="headerlink" title="C#迭代器"></a>C#迭代器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>程序设计的<a href="https://baike.baidu.com/item/软件设计模式/2117635" target="_blank" rel="noopener">软件设计模式</a>，可在容器（container，例如<a href="https://baike.baidu.com/item/链表/9794473" target="_blank" rel="noopener">链表</a>或<a href="https://baike.baidu.com/item/阵列/2644035" target="_blank" rel="noopener">阵列</a>）上遍访的接口，设计人员无需关心容器的内容。<a href="https://baike.baidu.com/item/迭代器/3803342?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
<ul>
<li>迭代器是产生值的有序序列的一个语句块。是实现函数成员的方式。</li>
<li>迭代器块在C#语法中不是独特的元素，它们在几个方面受到限制，并且主要作用在函数成员声明的语义上，它们在语法上只是语句块而已。</li>
</ul>
<h5 id="IEnumeraber-IEnumerator"><a href="#IEnumeraber-IEnumerator" class="headerlink" title="IEnumeraber IEnumerator"></a>IEnumeraber IEnumerator</h5><p><a href="https://www.cnblogs.com/w-wfy/p/7418464.html" target="_blank" rel="noopener">C# IEnumerator的详解</a></p>
<p>其他详见 Unity脚本编程-第八章</p>
<p><img src="../images/corountine_1.png" alt="corountine_1"></p>
<p>####糖块yield</p>
<p>yield 关键字向编译器指示它所在的方法是迭代器块</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>将当前集合中的元素立即返回</p>
<ul>
<li>yield return  返回元素</li>
<li>yield break   终止迭代</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>返回类型必须为 IEnumerable、IEnumerable<t>、IEnumerator 或 IEnumerator<t></t></t></li>
<li>参数前不能使用ref和out关键字</li>
<li>匿名方法中 不能使用yield</li>
<li>unsef中不能使用</li>
<li>yield return 不能置于 try-catch 块中。 可置于 try-finally 语句的 try 块中。   yield break   能 try 块或 catch 块，        不置于 finally 块</li>
</ul>
<h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>编程语言Lua从5.0版开始支持协程的概念，极大的扩展了Lua的能力。<a href="https://baike.baidu.com/item/Lua/7570719" target="_blank" rel="noopener">Lua</a>的协程通过扩展库coroutine来实现，其中的所有函数如下（具体可以参考Lua的官方manual）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`coroutine.create``coroutine.resume``coroutine.running``coroutine.status``coroutine.wrap``coroutine.yield`</span><br></pre></td></tr></table></figure>

<p>当前运行的代码可以看作运行在主协程中（就像C程序的main运行在主线程中），通过create可以创建一个协程，<a href="https://baike.baidu.com/item/resume/8876788" target="_blank" rel="noopener">resume</a>以运行此协程，直到新协程调用<a href="https://baike.baidu.com/item/yield/3824119" target="_blank" rel="noopener">yield</a>程序才能返回到”主协程“中运行。</p>
<p><strong>coroutine.create()</strong></p>
<p><strong>函数参数：</strong>接收单个参数，该参数是coroutine的主函数，即resume会执行的函数</p>
<p><strong>函数返回值：</strong>返回其控制器，一个对象为thread的对象</p>
<p><strong>函数作用：</strong>creat函数创建一个新的coroutine，定义了协程内的任务流程。从面对对象的角度来看，可以看成是coroutine类创建了一个对象co</p>
<p><strong>coroutine.resume(co,[val1,val2,…])</strong></p>
<p><strong>函数参数：</strong>第一个参数即creat的返回值，一个thread对象。第二个参数是coroutine中执行需要的参数，是一个变长参数，可以传入任意多个。</p>
<p><strong>函数返回值：</strong>当程序运行没有错误的时候，返回true，同时返回前一个调用coroutine.yield中传入的参数。如果有错误，返回错误false以及错误信息。</p>
<p><strong>函数作用：</strong>当第一次调用coroutine的resume方法的时候，其从主函数第一行开始执行，之后再coroutine开始运行后，它会一直运行到自身终止或者是coroutine的下一个yield函数。</p>
<p><strong>coroutine.yield(…)</strong></p>
<p><strong>函数参数：</strong>传入变长参数</p>
<p><strong>函数返回值：</strong>返回在前一个resume中传入的参数值</p>
<p><strong>函数作用：</strong>挂起当前的执行协程。该协程不能是一个C函数，一个元表或一个迭代器</p>
<p><strong>coroutine.running()：</strong>返回当前正在执行的协程</p>
<p><strong>coroutine.status()：</strong>返回当前协程的状态，有running/suspended/normal/dead等。</p>
<h3 id="Unity协程实现"><a href="#Unity协程实现" class="headerlink" title="Unity协程实现"></a>Unity协程实现</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><a href="https://blog.csdn.net/qq_16054639/article/details/80151445" target="_blank" rel="noopener">Unity脚本编程</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1437157" target="_blank" rel="noopener">生命周期</a></p>
<p>​        通过设置MonoBehaviour脚本的enabled对协程是没有影响的，但如果 gameObject.SetActive(false) 则已经启动的协程则完全停止了，即使在Inspector把gameObject 激活还是没有继续执行。也就说协程虽然是在MonoBehvaviour启动的（StartCoroutine）但是协程函数的地位完全是跟MonoBehaviour是一个层次的，不受MonoBehaviour的状态影响，但跟MonoBehaviour脚本一样受gameObject 控制，也应该是和MonoBehaviour脚本一样每帧“轮询” yield 的条件是否满足。</p>
<p>####开启函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StartCoroutine(Test_00()); // IEnumerator</span><br><span class="line">StartCoroutine(&quot;Test_01&quot;);</span><br><span class="line">StartCoroutine(Test_02(5, 9));</span><br></pre></td></tr></table></figure>

<h4 id="终止函数"><a href="#终止函数" class="headerlink" title="终止函数"></a>终止函数</h4><ul>
<li>StopCoroutine(“<strong>name</strong>“)</li>
<li>StopAllCoroutines</li>
</ul>
<ol>
<li><p>它们只能终止改MonoBehaviour中的协程</p>
</li>
<li><p>还有一种方法可以终止协同程序，即将协同程序所在gameobject的active属性设置为false，当再次设置active为ture时，协同程序并不会再开启；如是将协同程序所在脚本的enabled设置为false则不会生效。-原因见上面</p>
</li>
</ol>
<p><a href="http://www.xuanyusong.com/archives/1427" target="_blank" rel="noopener">雨松momo</a></p>
<p>####yield</p>
<p>yield return 0 or yield return null:程序在下一帧中从当前位置继续执行</p>
<p>yield return 1,2,3,……: 程序等待1，2，3…帧之后从当前位置继续执行</p>
<p>yield return new WaitForSeconds(n):程序等待n秒后从当前位置继续执行</p>
<p>yield new WaitForEndOfFrame():在所有的渲染以及GUI程序执行完成后从当前位置继续执行</p>
<p>yield new WaitForFixedUpdate():所有脚本中的FixedUpdate()函数都被执行后从当前位置继续执行</p>
<p>yield return WWW:等待一个网络请求完成后从当前位置继续执行</p>
<p>yield return StartCoroutine():等待一个协程执行完成后从当前位置继续执行</p>
<p>true</p>
<p>False</p>
<p>备注：曾经尝试在协程中加入停止后从新启用的功能，怕是个智障。</p>
<p>Bool isTodo;</p>
<p>ie test（）{</p>
<p>​    while(isTodo){</p>
<p>​    }</p>
<p>yiled return </p>
<p>Do Fun();</p>
<p>}</p>
]]></content>
      <categories>
        <category>C#</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>Lua</tag>
        <tag>协程</tag>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua元表</title>
    <url>/2019/10/25/Lua%E5%85%83%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2019/10/25/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua迭代器</title>
    <url>/2019/10/25/Lua%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="标准库提供的几种迭代器："><a href="#标准库提供的几种迭代器：" class="headerlink" title="标准库提供的几种迭代器："></a>标准库提供的几种迭代器：</h2><p><strong>io.lines</strong>(迭代文件中的每行),</p>
<p><strong>pairs</strong>(迭代table元素),<strong>ipairs</strong>(迭代数组元素)</p>
<p><strong>string.gmatch</strong>(迭代字符串中单词)等。</p>
<h2 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h2><h2 id="迭代器与闭包"><a href="#迭代器与闭包" class="headerlink" title="迭代器与闭包"></a>迭代器与闭包</h2><p>pairs见next</p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua泛型for</title>
    <url>/2019/10/25/Lua%E6%B3%9B%E5%9E%8Bfor/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>LuaLoadString</title>
    <url>/2019/10/25/LuaLoadString/</url>
    <content><![CDATA[<p>Lua 5.2 已删除，替代API:Load()</p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>LoadString</tag>
      </tags>
  </entry>
  <entry>
    <title>LuaUnPack</title>
    <url>/2019/10/25/LuaUnPack/</url>
    <content><![CDATA[<p>unpack( )函数是接受一个数组（table 连续的）来作为输入参数，并默认从下标为1开始返回所有元素。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125; <span class="built_in">print</span>(<span class="built_in">unpack</span>(t))</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>运行结果： a   b   c   d </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">unpack</span>(t,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">local</span> x, y, z = <span class="built_in">unpack</span>(t,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果： b   c   d 从下标2开始返回所有元素。</p>
<p>-遇</p>
<p>f（unpack（））泛型调用，作为参数返回。 </p>
<p>或返回return unpack（t）结构元素的值</p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua排序</title>
    <url>/2019/10/25/Lua%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="Value排序"><a href="#Value排序" class="headerlink" title="Value排序"></a>Value排序</h2><p>Lua 中table.Sort(table, fun) or table.Sort(t)</p><ul>
<li>不稳定排序 -快排</li>
<li>连续<strong>数组</strong></li>
<li>默认小于(升序)排</li>
</ul><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> test_table = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">local</span> teas_table = &#123;&#123;<span class="number">3</span>, b = <span class="string">"3"</span>&#125;,&#123;c = <span class="string">""</span>, b = <span class="number">4</span>&#125;,&#123;b = <span class="number">5</span>&#125;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(teas_table, funtion(x, y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tostring</span>(x.b) &lt; <span class="built_in">tostring</span>(y.b) </span><br><span class="line">    // 不能带 =：如 &gt;= | &lt;=</span><br><span class="line">    // 带报错：attempt to compare number with <span class="literal">nil</span>和invalid order <span class="function"><span class="keyword">function</span> <span class="title">for</span> <span class="title">sorting</span></span></span><br><span class="line"><span class="function">    // 原因：比较函数需要满足非对称和传递性质 </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">a.level</span> ~= <span class="title">b.level</span> <span class="title">then</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">a.level</span> &gt; <span class="title">b.level</span></span></span><br><span class="line"><span class="function">    <span class="title">end</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">a.exp</span> &gt; <span class="title">b.exp</span></span></span><br><span class="line"><span class="function">  &#125;)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note that the comp function must define a strict partial order over the elements in the list; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.</p>
<p><a href="http://www.lua.org/source/5.1/ltablib.c.html" target="_blank" rel="noopener">http://www.lua.org/source/5.1/ltablib.c.html</a></p>
<p>报错位置 <em>*for (;;) {  */\</em> invariant: a[l..i] &lt;= P &lt;= a[j..u] */* **</p>
<p>可以看到是边界判断的地方出了问题。假定传入的排序函数在遇到a == b 的时候返回false,因而底层的排序函数没有对这种情况进行严格的边界检查。</p>
</blockquote>
<h2 id="Key排序"><a href="#Key排序" class="headerlink" title="Key排序"></a>Key排序</h2><p>取key放入新表，排序。然后映射。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> test1 =&#123;a=<span class="number">1</span>,f=<span class="number">9</span>,d=<span class="number">2</span>,c=<span class="number">8</span>,b=<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key_test =&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">pairs</span>(test1) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">table</span>.<span class="built_in">insert</span>(key_test,i)   <span class="comment">--提取test1中的键值插入到key_test表中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(key_test)</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(key_test) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(v,test1[v])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/coffeecato/article/details/79117700" target="_blank" rel="noopener">https://blog.csdn.net/coffeecato/article/details/79117700</a></p>
<p><a href="http://pkxpp.github.io/2016/07/26/lua学习笔记(6)table.sort/" target="_blank" rel="noopener">http://pkxpp.github.io/2016/07/26/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)table.sort/</a></p>
<p><a href="https://blog.csdn.net/David_Dai_1108/article/details/46434787" target="_blank" rel="noopener">https://blog.csdn.net/David_Dai_1108/article/details/46434787</a></p>
<ul>
<li><a href="https://www.cnblogs.com/jadeboy/p/4101732.html" target="_blank" rel="noopener">https://www.cnblogs.com/jadeboy/p/4101732.html</a> </li>
</ul>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LuaClass</title>
    <url>/2019/10/25/LuaClass/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>数字反转</title>
    <url>/2019/10/25/%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>第n-i与第i交换。实质上数字倒置。</p>
<p><img src="https://img-blog.csdnimg.cn/20190720132732651.png" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void SceNum(int num)</span><br><span class="line">        &#123;</span><br><span class="line">            int result = 0;</span><br><span class="line">            while (num &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                result = result * 10 + (num + 5) % 10;</span><br><span class="line">                num /= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.Write(result);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>奇数左边</title>
    <url>/2019/10/25/%E5%A5%87%E6%95%B0%E5%B7%A6%E8%BE%B9/</url>
    <content><![CDATA[<p>思路：左右分开查找并替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void PutOddToLeft(int[] arr) &#123;</span><br><span class="line"> if (arr.Length &lt;= 0)</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line"> if (arr.Length == 1)</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line"> int l = 0;</span><br><span class="line"> int r = arr.Length - 1;</span><br><span class="line"> int tmp;</span><br><span class="line"> </span><br><span class="line"> while(l &lt; r) &#123; </span><br><span class="line">   while(arr[l] % 2 == 1 &amp;&amp; l &lt; r) &#123;</span><br><span class="line">     l++;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   while (arr[r] % 2 == 0 &amp;&amp; r &gt; l) &#123;</span><br><span class="line">     r--;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (l &gt;= r)</span><br><span class="line">     break;</span><br><span class="line"> </span><br><span class="line">   tmp = arr[l];</span><br><span class="line">   arr[l] = arr[r];</span><br><span class="line">   arr[r] = tmp;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HHTimeRecorder</title>
    <url>/2019/10/21/HHTimeRecorder/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class HHTimeRecorder</span><br><span class="line">&#123;</span><br><span class="line">  private DateTime beginTime;</span><br><span class="line">  public void Begin()</span><br><span class="line">  &#123;</span><br><span class="line">    beginTime = DateTime.Now;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long End()</span><br><span class="line">  &#123;</span><br><span class="line">    var ret = DateTime.Now - beginTime;</span><br><span class="line">    return ret.Ticks / 10000;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void End(string prefix)</span><br><span class="line">  &#123;</span><br><span class="line">    var costTime = End();</span><br><span class="line">    HHLogger.DEBUG(prefix, &quot;cost time&quot;, costTime, &quot;ms&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>构造和析构</title>
    <url>/2019/08/01/%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<p><strong>派生类构造函数执行的次序</strong>：</p><ol>
<li><p>调用<strong>基类构造</strong>函数，调用顺序按照它们 被继承时声明的顺序 （<strong>从左到右</strong>）；</p>
</li>
<li><p>调用<strong>内嵌成员对象</strong>的构造函数，调用顺序按照它们在类中声明的顺序；</p>
</li>
<li><p>派生类自己构造函数体中的内容。</p>
</li>
</ol><a id="more"></a>

<p><strong>派生类析构函数执行的次序</strong>：<br>派生类的析构函数的功能是在该对象消亡之前进行一些必要的清理工作，析构函数没有类型，也没有参数。</p>
<p>析构函数的执行顺序与构造函数相反。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>构造</tag>
        <tag>析构</tag>
      </tags>
  </entry>
  <entry>
    <title>FSM有限状态机</title>
    <url>/2019/08/01/FSM%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>了解FSM之前需要了解一下状态机</p><p>FSM是状态机的一种实现方式，它把复杂的控制逻辑分解成有限个稳定状态，在每个状态上判断事件，变连续处理为离散数字。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>发生事件(event)后，根据当前状态(cur_state) ，决定执行的动作(action)，并设置下一个状态号(nxt_state)。</p><a id="more"></a>


<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>有限</li>
<li>状态离散性</li>
</ul>
<p>因为有限状态机是个封闭系统，具有结束状态，所以它是有限的。</p>
<p>状态离散性：离散的某一时刻只能处于某种状态之下，且需要满足某种条件才能从一种状态转移到另一种状态。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>状态机的设计状态之间的关系是一个麻烦的事情，所以在设计的过程中需要借助状态图或者状态表来设计。</p>
<p>个人喜欢现态/次态表，其中填写事件和动作，然后将条件梳理。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>FSM实现事件检测可以通过“轮询”或者“事件驱动”的方式。下面代码是采用轮询的方式。</p>
<p>这是一本书中提到的<a href="http://wiki.unity3d.com/index.php?title=Finite_State_Machine" target="_blank" rel="noopener">通用FSM状态机源码 </a>其中包括了1.Description 2.Component 3.C#-FSMSystem.cs 4.Example。</p>
<p>部分代码展示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Transition</span><br><span class="line">&#123;</span><br><span class="line">    NullTransition = 0,</span><br><span class="line">&#125;</span><br><span class="line"> public enum StateID</span><br><span class="line">&#123;</span><br><span class="line">    NullStateID = 0,</span><br><span class="line">&#125;</span><br><span class="line"> public abstract class FSMState</span><br><span class="line">&#123;</span><br><span class="line">    protected Dictionary&lt;Transition, StateID&gt; map = new Dictionary&lt;Transition, StateID&gt;();</span><br><span class="line">    protected StateID stateID;</span><br><span class="line">    public StateID ID &#123; get &#123; return stateID; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    public void AddTransition(Transition trans, StateID id)&#123;&#125;</span><br><span class="line">    public void DeleteTransition(Transition trans)&#123;&#125;</span><br><span class="line">    public StateID GetOutputState(Transition trans)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public virtual void DoBeforeEntering() &#123; &#125;</span><br><span class="line">    public virtual void DoBeforeLeaving() &#123; &#125; </span><br><span class="line"></span><br><span class="line">    public abstract void Reason(GameObject player, GameObject npc);</span><br><span class="line">    public abstract void Act(GameObject player, GameObject npc);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class FSMSystem</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;FSMState&gt; states;</span><br><span class="line">    private StateID currentStateID;</span><br><span class="line">    public StateID CurrentStateID &#123; get &#123; return currentStateID; &#125; &#125;</span><br><span class="line">    private FSMState currentState;</span><br><span class="line">    public FSMState CurrentState &#123; get &#123; return currentState; &#125; &#125;</span><br><span class="line">    public FSMSystem()</span><br><span class="line">    &#123;</span><br><span class="line">       states = new List&lt;FSMState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void AddState(FSMState s)&#123;&#125;</span><br><span class="line">    public void DeleteState(StateID id)&#123;&#125;</span><br><span class="line">    public void PerformTransition(Transition trans)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点</li>
<li>缺点</li>
</ul>
<p>优点：相对简单的状态机来使用swich那样不方便扩展，将事件放置具体状态中相对来说好维护</p>
<p>缺点：1.随着状态的增加我们会发现有很多相似的状态 2.随着状态的增多，维护链接成本还是很高的 3.很难做到状态并行 </p>
<p>下图是我画的状态图</p>
<p>它的表现效果是双方士兵们出阵然后开始群殴，直至一方士兵全部死亡。当时并没有采用现态/次态表，很遗憾很乱，而且事件条件很乱很有可以会出错。如果这时候策划来说，我感觉一方敌人全部死亡之后，呆呆的站在那里很难受，让他们庆祝一下吧。这时候我很方便的添加一个庆祝状态，庆祝之后站立。</p>
<p>它状态少的时候还好，状态多的时候就很尴尬，维护起来的成本很高。而且无法达到并行的目的。而且出阵和冲锋其实有点相似的。状态机的确满足了我的项目需求，但是不可否认的是FSM本身存在的问题，不过相比BT(行为树)自顶向下的轮询方式，它起码可以采用事件驱动的方式来实现状态切换，而且在针对简单的项目需求还是蛮有效的，所以在游戏开发中需要根据具体情况去合理的在状态机和BT之间权衡。然后采用适合自己的项目的方式实现，如下面的扩展。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li>分层状态机</li>
<li>并行状态机</li>
<li>BT行为树</li>
<li>神经网络</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>FSM</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>windows-屏幕阅读器</title>
    <url>/2019/07/31/windows-%E5%B1%8F%E5%B9%95%E9%98%85%E8%AF%BB%E5%99%A8/</url>
    <content><![CDATA[<p>莫名开启的讲述人功能</p>
<p>快捷键开启 ctr + window + Enter</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机</title>
    <url>/2019/07/27/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>状态机：描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应的模型。</p><p>用来表示有限多个状态以及在这些状态（State）之间转移（Transition）和动作（Action）的数学模型。</p><a id="more"></a>

<p>简单的说它可以<strong>将单位的所有行为去划分状态，状态与状态之间通过事件的触发形成。</strong></p>
<p><strong>状态机可归纳为4个要素，即现态，条件，动作，次态。</strong></p>
<ul>
<li>现态：是指当前所处的状态。</li>
<li>条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li>
<li>动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。<strong>动作不是必需的</strong></li>
<li>次态：条件满足后要迁往的新状态。</li>
</ul>
<p>事件：1.检测转换条件 2.进行状态切换</p>
<h2 id="设计状态机"><a href="#设计状态机" class="headerlink" title="设计状态机"></a>设计状态机</h2><ul>
<li>可以用状态移动图表示</li>
<li>可以用表格来表示，如：事件/状态表，现态/次态表…</li>
</ul>
<p>AI设计中个人喜欢现态/次态表</p>
<p><img src="https://img-blog.csdnimg.cn/20190715014012283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="状态机分类"><a href="#状态机分类" class="headerlink" title="状态机分类"></a>状态机分类</h2><ul>
<li>Moore状态机：输出只和状态有关而与输入无关</li>
<li>Mealy状态机：输出不仅和状态有关而且和输入有关系</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>竖向：swich，if..else</li>
<li>横向：FSM </li>
</ul>
<h2 id="附录：竖向写"><a href="#附录：竖向写" class="headerlink" title="附录：竖向写"></a>附录：竖向写</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cur_state = nxt_state;</span><br><span class="line"></span><br><span class="line">switch(cur_state)&#123; //在当前状态中判断事件</span><br><span class="line"></span><br><span class="line">case s0: //在s0状态</span><br><span class="line"></span><br><span class="line">if(e0_event)&#123; //如果发生e0事件，那么就执行a0动作，</span><br><span class="line"></span><br><span class="line">并保持状态不变；</span><br><span class="line"></span><br><span class="line">执行a0动作;</span><br><span class="line"></span><br><span class="line">//nxt_state = s0; //因为状态号是自身，所以可以删除此句</span><br><span class="line"></span><br><span class="line">，以提高运行速度。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if(e1_event)&#123; //如果发生e1事件，那么就执行a1动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s1态；</span><br><span class="line"></span><br><span class="line">执行a1动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if(e2_event)&#123; //如果发生e2事件，那么就执行a2动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s2态；</span><br><span class="line"></span><br><span class="line">执行a2动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case s1: //在s1状态</span><br><span class="line"></span><br><span class="line">if(e2_event)&#123; //如果发生e2事件，那么就执行a2动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s2态；</span><br><span class="line"></span><br><span class="line">执行a2动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case s2: //在s2状态</span><br><span class="line"></span><br><span class="line">if(e0_event)&#123; //如果发生e0事件，那么就执行a0动作，</span><br><span class="line"></span><br><span class="line">并将状态转移到s0态；</span><br><span class="line"></span><br><span class="line">执行a0动作;</span><br><span class="line"></span><br><span class="line">nxt_state = s0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>FSM</tag>
        <tag>状态机</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度，空间复杂度和稳定性</title>
    <url>/2019/07/26/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<p>时间复杂度，空间复杂度和稳定性</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>指的是算法执行语句的次数（取最多次数的那个语句来表示）<br><img src="https://img-blog.csdnimg.cn/20190721132322442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>a^x^ =N（a&gt;0，且a≠1） ==&gt; x=log<del>a</del>N<br>注： Hash的查找的时间复杂度是1，原因“key-value键值对”，离散的</p><a id="more"></a>

<p>下面是3个例子关于while简单的理解一下时间复杂度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一个算法执行次数是20，常量所以是O(1)</span><br><span class="line">int x = 1;</span><br><span class="line">while (x&lt;20)</span><br><span class="line">&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二个执行次数是n决定，O(n)</span><br><span class="line">int x = 1;</span><br><span class="line">while (x&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行次数由 c 和 n共同决定，c = 1 时，O(1)，c != 1时，O(n)</span><br><span class="line">int x = 1;</span><br><span class="line">c = c or 1;</span><br><span class="line">while (x&lt;n &amp;&amp; c != 1)</span><br><span class="line">&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个简单插入排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 分类 ------------- 内部比较排序</span><br><span class="line">// 数据结构 ---------- 数组</span><br><span class="line">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span><br><span class="line">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span><br><span class="line">// 平均时间复杂度 ---- O(n^2)</span><br><span class="line">// 所需辅助空间 ------ O(1)</span><br><span class="line">// 稳定性 ------------ 稳定</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;;// 从小到大插入排序</span><br><span class="line">    int n = sizeof(A) / sizeof(int);</span><br><span class="line">    int i, j, get;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; n; i++)             // 类似抓扑克牌排序</span><br><span class="line">    &#123;</span><br><span class="line">        get = A[i];                     // 右手抓到一张扑克牌</span><br><span class="line">        j = i - 1;                      // 拿在左手上的牌总是排序好的</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; A[j] &gt; get)    // 将抓到的牌与手牌从右向左进行比较</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + 1] = A[j];            // 如果该手牌比抓到的牌大,就将其右移</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + 1] = get;// 直到该手牌比抓到的牌小(或二者相等),将抓到的牌插入到该手牌右边(相等元素的相对次序未变,所以插入排序是稳定的)</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;插入排序结果：&quot;);</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进一下，第二层采用二分查找法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 分类 -------------- 内部比较排序</span><br><span class="line">// 数据结构 ---------- 数组</span><br><span class="line">// 最差时间复杂度 ---- O(n^2)</span><br><span class="line">// 最优时间复杂度 ---- O(nlogn)</span><br><span class="line">// 平均时间复杂度 ---- O(n^2)</span><br><span class="line">// 所需辅助空间 ------ O(1)</span><br><span class="line">// 稳定性 ------------ 稳定</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大二分插入排序</span><br><span class="line">    int n = sizeof(A) / sizeof(int);</span><br><span class="line">    int i, j, get, left, right, middle;</span><br><span class="line">    </span><br><span class="line">    for (i = 1; i &lt; n; i++)                 // 类似抓扑克牌排序</span><br><span class="line">    &#123;</span><br><span class="line">        get = A[i];                         // 右手抓到一张扑克牌</span><br><span class="line">        left = 0;                           // 拿在左手上的牌总是排序好的,所以可以用二分法</span><br><span class="line">        right = i - 1;                      // 手牌左右边界进行初始化</span><br><span class="line">        while (left &lt;= right)               // 采用二分法定位新牌的位置</span><br><span class="line">        &#123;</span><br><span class="line">            middle = (left + right) / 2;</span><br><span class="line">            if (A[middle] &gt; get)</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            else</span><br><span class="line">                left = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = i - 1; j &gt;= left; j--)    // 将欲插入新牌位置右边的牌整体向右移动一个单位</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + 1] = A[j];            </span><br><span class="line">        &#125;</span><br><span class="line">        A[left] = get;                    // 将抓到的牌插入手牌</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;二分插入排序结果：&quot;);</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改进一下，成为希尔排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line"></span><br><span class="line">// 分类 -------------- 内部比较排序</span><br><span class="line">// 数据结构 ---------- 数组</span><br><span class="line">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span><br><span class="line">// 最优时间复杂度 ---- O(n)</span><br><span class="line">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span><br><span class="line">// 所需辅助空间 ------ O(1)</span><br><span class="line">// 稳定性 ------------ 不稳定</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大希尔排序</span><br><span class="line">    int n = sizeof(A) / sizeof(int);</span><br><span class="line">    int i, j, get;</span><br><span class="line">    int h = 0;</span><br><span class="line">    while (h &lt;= n)                          // 生成初始增量</span><br><span class="line">    &#123;</span><br><span class="line">        h = 3*h + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (h &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = h; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i - h;</span><br><span class="line">            get = A[i];</span><br><span class="line">            while ((j &gt;= 0) &amp;&amp; (A[j] &gt; get))</span><br><span class="line">            &#123;</span><br><span class="line">                A[j + h] = A[j];</span><br><span class="line">                j = j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + h] = get;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h - 1) / 3;                    // 递减增量</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;希尔排序结果：&quot;);</span><br><span class="line">    for (i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>指对一个算法在运行过程中临时占用存储空间，看你开辟的临时空间就好了。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><h3 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h3><p>指的是针对相同数值，在排序前后是否有发生变化的可能。一般举返例来证明</p>
<blockquote>
<p>这只是一个例子来说明稳定性，大家普遍说冒泡是稳定的，条件换成“&gt;=”导致算法不稳定，建议不要</p>
</blockquote>
<p>下面是个简单冒泡排序来排序｛1，1，1，1，1，1，2， 2，1｝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int j = 0; j &lt; n - 1; j++)           </span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; n - 1 - j; i++)   </span><br><span class="line">        &#123;</span><br><span class="line">            if (A[i] &gt; A[i + 1])            // 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法</span><br><span class="line">            &#123;</span><br><span class="line">                exchange(A, i, i + 1);        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值稳定性"><a href="#数值稳定性" class="headerlink" title="数值稳定性"></a>数值稳定性</h3><p>讨论的是计算机编程中，由于四舍五入等导致的结果偏差。</p>
<ul>
<li>尽量减少运算次数</li>
<li>加法运算时，避免大数加小数</li>
<li>避免两个相近的数相减</li>
<li>避免小数做除法或者大数做乘法</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="常见排序总结"><a href="#常见排序总结" class="headerlink" title="常见排序总结"></a>常见排序总结</h3><p><img src="https://img-blog.csdnimg.cn/20190721132409247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGVyS2V5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://www.cnblogs.com/hubgit/p/6743513.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">编程排序算法</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityTimeUitll</title>
    <url>/2018/11/07/UnityTimeUitll/</url>
    <content><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>为了解决代码到处存在倒计时，每次进行计时的时候，都要一向上传递Update方法。还有就是为了解决游戏中定时任务的触发问题</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>设计了一个计时任务单元Event，来存放所需要触发的回调事件和属性</p><p>设计了一个计时管理Timetask来处理任务单元</p><a id="more"></a>


<p>设计了一个对外的TimeUtil</p>
<p>当然还有一些其他的，这个看源码你就知道了</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>我选择了限制计时器1秒走一次。来减少Update里函数的执行次数</p>
<p>我选择了让服务器给我一个当前时间戳（一次）作游戏的起始时间。通过Time.realtimeSinceStartup来获取游戏运行时间，来保证了与服务器的时间的一致性。之前我错误的使用了Time.time</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>你可以在任何需要等待时间处理的事物上，选择使用它，哪怕是UI需要显示的倒计时。</p>
<p>不过它不能在你第一次添加任务回调的时候立即执行你的回调。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/Mlik5hao/Time" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>C#</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>Time</tag>
        <tag>管理器</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity打包ios并上架</title>
    <url>/2018/10/27/Unity%E6%89%93%E5%8C%85ios%E5%B9%B6%E4%B8%8A%E6%9E%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>打包</tag>
        <tag>ios</tag>
        <tag>上架</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityPlayerSettings</title>
    <url>/2018/10/27/UnityPlayerSettings/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/9bb8d6f6ddce" target="_blank" rel="noopener">https://www.jianshu.com/p/9bb8d6f6ddce</a></p>
<p><a href="https://gameinstitute.qq.com/community/detail/127960" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/127960</a></p>
<p><a href="https://blog.csdn.net/David_Dai_1108/article/details/79184249" target="_blank" rel="noopener">https://blog.csdn.net/David_Dai_1108/article/details/79184249</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>PlayerSetting</tag>
      </tags>
  </entry>
  <entry>
    <title>mac配置AndroidStudio打包环境</title>
    <url>/2018/10/26/mac%E9%85%8D%E7%BD%AEAndroidStudio%E6%89%93%E5%8C%85%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h5 id="AS，SDK"><a href="#AS，SDK" class="headerlink" title="AS，SDK"></a>AS，SDK</h5><p><a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">https://www.androiddevtools.cn/</a></p><h5 id="JDK-注册账号"><a href="#JDK-注册账号" class="headerlink" title="JDK -注册账号"></a>JDK -注册账号</h5><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html?utm_source=androiddevtools&amp;utm_medium=website" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html?utm_source=androiddevtools&amp;utm_medium=website</a></p><a id="more"></a>

<h5 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h5><p>直接在Unity中Download</p>
<h5 id="打包Android-Project"><a href="#打包Android-Project" class="headerlink" title="打包Android Project"></a>打包Android Project</h5><p>Go to <strong>Build Settings</strong> and make sure Android is selected as the target platform. Change the <strong>Build System</strong> to <strong>Gradle</strong>, and tick the <strong>Export Project</strong> checkbox, as shown in the picture below.</p>
<p><strong>Build Setting</strong></p>
<ul>
<li>Internal（Default）：Unity内置，仅需Android SDK支持。不能导出工程，适用于仅适用Unity开发的工程。</li>
<li>Gradle（New）：使用Gradle进行构建，需要Android SDK与Gradle支持。可以导出Android Studio工程，选这个才能勾选下面的Export Project，适用于Unity与Android交互的项目。</li>
</ul>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>–TODO</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>打包</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua其他</title>
    <url>/2018/10/25/Lua%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h5 id="lua特点"><a href="#lua特点" class="headerlink" title="lua特点"></a>lua特点</h5><p>脚本语言，嵌入式，标准C编写；8个数据类型1个数据结构；可作为脚本或者配置文件<br>特点：</p><ol>
<li>可扩展（接口和机制）</li>
<li>支持面向过程编程和函数式编程</li>
</ol><p><del>动态语言，Lua轻量级嵌入式语言，标准C编写而成<br>可作为脚本或者配置文件,将table作为唯一的数据结构，官方将table分为两种一个为数组一个为哈希。<br>Lua解释器小<br>轻量级（由标C编写，嵌入式编程），可扩展（接口和机制）。支持面向过程编程和函数式编程。</del> </p><a id="more"></a>


<h5 id="lua数据类型"><a href="#lua数据类型" class="headerlink" title="lua数据类型"></a>lua数据类型</h5><p>8个：nil、boolean、number、string、userdata、function、thread和table。<br>其中：Lua 把 false 和 nil 看作是”假”，其他的都为”真”</p>
<h5 id="pairs-与-ipairs的区别"><a href="#pairs-与-ipairs的区别" class="headerlink" title="pairs 与 ipairs的区别"></a>pairs 与 ipairs的区别</h5><p>pairs：迭代table，可以遍历表中所有key可以返回nil<br>ipairs：迭代数组，不能返回nil，遇见nil退出</p>
<h5 id="lua元表"><a href="#lua元表" class="headerlink" title="lua元表"></a>lua元表</h5><p>元表：对不同table之间进行操作，允许改变table行为且每个行为关联对应元方法。<br>setmetatable：设置table为元表（metatable）<br>      注：如果元表中存在__metatable键值，set会失败<br>getmetatable：返回对象元表（metatable）</p>
<h5 id="LuaClass"><a href="#LuaClass" class="headerlink" title="LuaClass"></a>LuaClass</h5><p>见链接<br>云风 ：缺点 无法调用同名父类函数<br><a href="https://blog.csdn.net/MilerKey/article/details/96457594" target="_blank" rel="noopener">https://blog.csdn.net/MilerKey/article/details/96457594</a></p>
<h5 id="Lua闭包"><a href="#Lua闭包" class="headerlink" title="Lua闭包"></a>Lua闭包</h5><p><a href="https://blog.csdn.net/MilerKey/article/details/96461578" target="_blank" rel="noopener">https://blog.csdn.net/MilerKey/article/details/96461578</a></p>
<h5 id="Lua优化细节"><a href="#Lua优化细节" class="headerlink" title="Lua优化细节"></a>Lua优化细节</h5><h5 id="C-和Lua的互相调用"><a href="#C-和Lua的互相调用" class="headerlink" title="C#和Lua的互相调用"></a>C#和Lua的互相调用</h5><p><a href="https://blog.csdn.net/Pan_mouren/article/details/81000303" target="_blank" rel="noopener">https://blog.csdn.net/Pan_mouren/article/details/81000303</a><br>虚拟栈，wrap完成注册</p>
<p> Lua Call C#:先生成C#源文件所对应的Wrap文件或者编写C#源文件所对应的c模块，然后将源文件内容通过Wrap文件或者C模块注册到Lua解释器中，然后由Lua去调用这个模块的函数。<br> C# Call Lua：C#把请求或数据放在栈顶，然后lua从栈顶取出该数据，在lua中做出相应处理（查询，改变），然后把处理结果放回栈顶，最后C#再从栈顶取出lua处理完的数据，完成交互。</p>
<h5 id="C-和Lua交互以及注意事项"><a href="#C-和Lua交互以及注意事项" class="headerlink" title="C#和Lua交互以及注意事项"></a>C#和Lua交互以及注意事项</h5><p>lua-C-C#。C#调用lua的过程是C#-C-lua。<br><a href="https://blog.uwa4d.com/archives/USparkle_Lua.html" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/USparkle_Lua.html</a></p>
<h5 id="Lua热更新的原理实现"><a href="#Lua热更新的原理实现" class="headerlink" title="Lua热更新的原理实现"></a>Lua热更新的原理实现</h5><p>Lua的 require(modelname) 把一个lua文件加载存放到package.loaded[modelname]。<br>当我们加载一个模块的时候，会先判断是否在package.loaded中已存在，若存在则返回改模块，不存在才会加载(loadfile)，防止重复加载。<br>package.loaded是一个Table，其中包含了全局表_G、默认加载的模块(string, debug, package, io, os, table, math, coroutine)和用户加载的模块。</p>
<h5 id="为什么选择Lua作为热更新"><a href="#为什么选择Lua作为热更新" class="headerlink" title="为什么选择Lua作为热更新"></a>为什么选择Lua作为热更新</h5><p>回答问题前先说明几个问题：<br>1、ios支持反射，C#写的反射代码都可以正常使用。但是不支持Reflection.Emit。<br>2、ios不能用c# jit，事实上我们在ios上的代码是AOT的。<br>3、ios不能用c#热更是因为启动了CPU的No eXecute bit，简单说就是AppStore审核过的代码才能执行。而lua解释器是审核过的，这才是为何lua可以运行在ios上的根本原因。</p>
<p>回答正题：<br>Q：请问lua怎么做热更新？<br>A：lua的执行依赖于其解释器，通常来说就是lua.c中的代码。lua在unity中作为一个文本资源来使用，当我们通过tolua或者xlua调用lua代码中某个函数时，解释器会去对lua进行解释，因为lua解释器代码允许执行，因此它会执行lua解释后的代码。<br>Q：是把逻辑用lua脚本来写？<br>A：基本就是游戏玩法的代码。网络、资源加载等基础模块一般不会变，所有很多都是用C#写的。说白了，不变的代码用C#写更高效，变化的代码用lua写。<br>Q：还是lua只用来打包资源？<br>A：打包和lua唯一的关系就是lua代码文件作为资源被打包。</p>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
</search>
